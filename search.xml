<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XMind 8永久破解]]></title>
    <url>%2F2018%2F12%2F12%2FXMind%208%2F</url>
    <content type="text"><![CDATA[下载点击XMind官网下载 破解 安装完成后，到百度网盘 ：链接: https://pan.baidu.com/s/1VAJyKvNutqLB2shaw137bQ 下载破解文件 提取码: 75w8 找到你的XMind安装目录，例如我安装的路径为 G:\xmind思维导图\XMind，将下载好的破解文件放到此文件夹下 在这个目录中，找到 XMind.ini 这个文件，用记事本打开此文件，在最后一行追加 -javaagent:G:\xmind思维导图\XMind\XMindCrack.jar，然后保存退出即可。 注意地址写你自己的安装路径 上面完成后，就可以打开 XMind, 依次点击 帮助——序列号，然后输入以下序列号 ，邮箱随便填一个就可以了。然后提示激活成功既可。 XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345 破解成功 注意：防止联网检查，打开 hosts 文件，在末尾追加两行行 ，或者给这个软件禁止联网权限127.0.0.1 www.xmind.net127.0.0.1 www.xmind.cn 6、找到hosts文件 Win：C:\Windows\System32\drivers\etc Mac：桌面顶部菜单栏，前往-前往文件夹，输入代码：/private/etc/ hosts文件目录 -&gt;C:\Windows\System32\drivers\etc ​ 7、在hosts里面追加代码（修改时需要注意，文件原本是只读，要把只读去了） Win：127.0.0.1 www.xmind.net 回车 Mac：127.0.0.1 www.xmind.net 回车（直接修改会提示无权修改，需要先将hosts文件复制到桌面，在桌面修改，然后在粘贴回去，覆盖原文件） 8、打开xmind 8 输入邮箱和序列号 帮助-&gt;序列号]]></content>
      <categories>
        <category>前端必备软件</category>
      </categories>
      <tags>
        <tag>前端必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5和CSS3详解1]]></title>
    <url>%2F2018%2F12%2F12%2FHTML5%E5%92%8CCSS3%E8%AF%A6%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[一：什么是HTML5： 万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言（HTML）的第五次重大修改 支持Html5的浏览器包括Firefox（火狐浏览器），IE9及其更高版本，Chrome（谷歌浏览器），Safari，Opera等；国内的傲游浏览器（Maxthon），以及基于IE或Chromium（Chrome的工程版或称实验版）所推出的360浏览器、搜狗浏览器、QQ浏览器、猎豹浏览器等国产浏览器同样具备支持HTML5的能力 HTML5的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如video、audio和canvas 标记。HTML5还引进了新的功能，可以真正改变用户与文档的交互方式 增加了新特性：语义特性，本地存储特性，设备兼容特性，连接特性，网页多媒体特性，三维、图形及特效特性，性能与集成特性，CSS3特性 相比之前的进步：取消了一些过时的HTML4标记，将内容和展示分离，一些全新的表单输入对象，全新的，更合理的Tag，本地数据库，Canvas 对象，浏览器中的真正程序，Html5取代Flash在移动设备的地位 优点： a) 提高可用性和改进用户的友好体验； b) 有几个新的标签，这将有助于开发人员定义重要的内容； c) 可以给站点带来更多的多媒体元素(视频和音频)； d) 可以很好的替代FLASH和Silverlight； e) 当涉及到网站的抓取和索引的时候，对于SEO很友好； f) 将被大量应用于移动应用程序和游戏； g) 可移植性好。 缺点：该标准并未能很好的被Pc端浏览器所支持。因新标签的引入，各浏览器之间将缺少一种统一的数据描述格式，造成用户体验不佳。 未来趋势 a. 移动优先 b. 游戏开发者领衔”主演” 二：HTML5中的新增标签为了更好地处理今天的互联网应用，HTML5添加了很多新元素及功能，比如： 图形的绘制，多媒体内容，更好的页面结构，更好的形式 处理，和几个api拖放元素，定位，包括网页 应用程序缓存，存储，网络工作者，等。 canvas \&lt;canvas> 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API 多媒体 \&lt;audio> 定义音频内容\&lt;video> 定义视频（video 或者 movie）\&lt;source> 定义多媒体资源 \&lt;video> 和 \&lt;audio> 字体\&lt;embed> 定义嵌入的内容，比如插件。\&lt;track> 为诸如 \&lt;video> 和 \&lt;audio> 元素之类的媒介规定外部文本轨道。 表单 \&lt;datalist> 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 \&lt;keygen> 规定用于表单的密钥对生成器字段。 \&lt;output> 定义不同类型的输出，比如脚本的输出。 语义和结构 HTML5提供了新的元素来创建更好的页面结构： 标签 描述 \&lt;article> 定义页面的侧边栏内容 \&lt;aside> 定义页面内容之外的内容。 \&lt;bdi> 允许您设置一段文本，使其脱离其父元素的文本方向设置。 \&lt;command> 定义命令按钮，比如单选按钮、复选框或按钮 \&lt;details> 用于描述文档或文档某个部分的细节 \&lt;dialog> 定义对话框，比如提示框 \&lt;summary> 标签包含 details 元素的标题 \&lt;figure> 规定独立的流内容（图像、图表、照片、代码等等）。 \&lt;figcaption> 定义 \&lt;figure> 元素的标题 \&lt;footer> 定义 section 或 document 的页脚。 \&lt;header> 定义了文档的头部区域 \&lt;mark> 定义带有记号的文本。 \&lt;meter> 定义度量衡。仅用于已知最大和最小值的度量。 \&lt;nav> 定义运行中的进度（进程）。 \&lt;progress> 定义任何类型的任务的进度。 \&lt;ruby> 定义 ruby 注释（中文注音或字符）。 \&lt;rt> 定义字符（中文注音或字符）的解释或发音。 \&lt;rp> 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 \&lt;section> 定义文档中的节（section、区段）。 \&lt;time> 定义日期或时间。 \&lt;wbr> 规定在文本中的何处适合添加换行符。 三,HTML中移除的标签：以下的 HTML 4.01 元素在HTML5中已经被删除: \&lt;acronym> 字体兼容 \&lt;applet> java组件 \&lt;basefont> 字体 \&lt;big> \&lt;center> \&lt;dir> 目录 \&lt;font> \&lt;frame> \&lt;frameset> \&lt;noframes> \&lt;strike> 四：HTML中的语义标签 传统页面的标签使用 HTML5页面中的标签使用，如： 12345678&lt;body&gt; &lt;header&gt;定义了文档的头部区域&lt;/header&gt; &lt;div&gt; &lt;article&gt;定义页面的侧边栏内容&lt;/article&gt; &lt;aside&gt;定义页面内容之外的内容&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;定义 section 或 document 的页脚&lt;/footer&gt;&lt;/body&gt; 五：兼容处理： 在不支持HTML5新标签的浏览器里，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用，但是在IE9版本以下，并不能正常解析这些新标签，但是却可以识别通过document.createElement(\’tagName\’)创建的自定义标签，于是我们的解决方案就是将HTML5的新标签全部通过document.createElement(\’tagName\’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了。 处理方式：在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载三方的一个JS库来解决兼容问题（测试在IE下面的兼容性：ieTester软件的使用） \&lt;script src=\”../js/html5shiv.min.js\”>\&lt;/script> 六：HTML5中表单新增的标签 \&lt;datalist>:与input配合使用：类似于拥有输入功能的下拉列表 \&lt;keygen>:提供一种验证用户数据的可靠方法。在提交表单数据的时候，会生成两个键，一个私钥，一个公钥。私钥存储在本地，公钥发送到服务器。在需要做验证的时候，我们可以从服务器下载一个客户端证书，通过私钥和证书来实现相关的验证操作。 \&lt;meter>:度量器，可用于标示级别 +———-+———-+—————————————————–+| 属性 | 值 | 描述 |+==========+==========+=====================================================+| high | number | 定义度量的值位于哪个点，被界定为高的值。 |+———-+———-+—————————————————–+| low | number | 定义度量的值位于哪个点，被界定为低的值。 |+———-+———-+—————————————————–+| max | number | 定义最大值。默认值是 1。 |+———-+———-+—————————————————–+| min | number | 定义最小值。默认值是 0。 |+———-+———-+—————————————————–+| optimum | number | 定义什么样的度量值是最佳的值。 || | | || | | 如果该值高于 \”high\” 属性，则意味着值越高越好。 || | | || | | 如果该值低于 \”low\” 属性的值，则意味着值越低越好。 |+———-+———-+—————————————————–+| value | number | 定义度量的值。 |+———-+———-+—————————————————–+ \&lt;output>:用于展示内容，只能展示，不能进行编辑 七：表单新增的属性 placeholder 占位符 autofocus 获取焦点 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成，用于表单元素，也可用于表单自身 form 指定表单项属于哪个form，处理复杂表单时会需要 novalidate 关闭验证，可用于\&lt;form>标签 required 验证条件，必填项 pattern 正则表达式 验证表单 autocomplete:属性规定表单是否应该启用自动完成功能。autocomplete 属性适用于 \&lt;form>，以及下面的 input 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。\&lt;br>\\&lt;form action=\”\” autocomplete=\”on\”>\autofocus定位文本框焦点：\ \&lt;br>\placeholder设置文本框默认提示：\&lt;input type=\”text\” placeholder=\”请输入***\”>\&lt;br>\email邮件类型自带验证和提示：\&lt;input type=\”email\”> \&lt;br>\required属性设置非空特性：\\&lt;br>\pattern设置验证规则：\&lt;input type=\”tel\” name=\”tel\” required pattern=\”\^(\+86)?1[358]\d{5}\$\”>\&lt;br>\multiple多文件选择：\\&lt;br>\\&lt;input type=\”submit\” value=\”提交\”/>\\&lt;/form> 八：表单的输入类型 a) email： 输入email格式 b) tel： 手机号码 c) url： 只能输入url格式 d) number： 只能输入数字 e) search： 搜索框 f) range： 范围，可以进行拖动，通过value进行取值 g) color ：拾色器，通过value进行取值 h) time ：时间 i) date： 日期 不是绝对的 j) datetime： 时间日期 k) month： 月份 l) week： 星期 说明：部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 九：表单新增的事件： oninput 用户输入内容时触发，可用于移动端输入字数统计 oninvalid 验证不通过时触发 \&lt;script>\/*oninput可以监听用户的每一次输入*/\document.getElementById(\”name\”).oninput=function(){\console.log(this.value);\}\/*监听键盘弹起，每一个键盘弹出触发一次*/\document.getElementById(\”name\”).onkeyup=function(){\console.log(\”---\”+this.value);\}\/*当指定表单元素验证不通过时触发*/\document.getElementById(\”phone\”).oninvalid=function(){\console.log(\”验证不通过\”);\}\\&lt;/script> 十：新增表单元素和属性的案例 效果图： 代码 a. 样式 \&lt;style>\*{\margin: 0;\padding: 0;\}\body{\max-width:600px;\margin: 0 auto;\}\form{\width:100%;\}\form fieldset{\padding:20px 20px 10px;\}\form fieldset label{\font-weight:bold;\line-height:20px;\}\form input,\form meter{\width:100%;\margin:10px 0;\display: block;\height:30px;\border: 1px solid #ccc;\padding-left:5px;\}\form meter{\width:100%;\border: none;\padding-left:0;\}\.btn{\width:100%;\height: 40px;\margin-top: 20px;\}\\&lt;/style> b. 结构 \&lt;body>\\&lt;form action=\”\”>\\&lt;fieldset>\\&lt;legend>学生档案\&lt;/legend>\\&lt;label for=\”userName\”>姓名:\&lt;/label>\\\\&lt;label for=\”phone\”>手机号码：\&lt;/label>\\&lt;input type=\”tel\” name=\”phone\” id=\”phone\” pattern=\”\^(\+86)?1[358]\d{9}\$\”>\\&lt;label for=\”email\”>邮箱地址：\&lt;/label>\\&lt;input type=\”email\” name=\”email\” id=\”email\”>\所属学院：\\&lt;input type=\”text\” list=\”school\” name=\”college\” id=\”college\” placeholder=\”请选择\”>\\&lt;datalist id=\”school\”>\\&lt;option>移动与前端开发学院\&lt;/option>\\&lt;option>IOS\&lt;/option>\\&lt;option>andriod\&lt;/option>\\&lt;option>c++\&lt;/option>\\&lt;/datalist>\\&lt;label for=\”score\”>入学成绩:\&lt;/label>\\&lt;input type=\”number\” max=\”100\” min=\”0\” step=\”1\” name=\”score\” id=\”score\” value=\”0\”>\\&lt;label for=\”level\”>基础水平\&lt;/label>\\&lt;!--通过low/high的值来设置meter的颜色-->\\&lt;meter name=\”level\” id=\”level\” value=\”0\” max=\”100\” min=\”0\” low=\”59\” high=\”90\”>\&lt;/meter>\\&lt;label for=\”inTime\”>入学日期\&lt;/label>\\&lt;input type=\”date\” name=\”inTime\” id=\”inTime\”>\\&lt;label for=\”leaveTime\”>毕业日期\&lt;/label>\\&lt;input type=\”date\” name=\”leaveTime\” id=\”leaveTime\”>\\&lt;input type=\”submit\” name=\”submit\” id=\”submit\” class=\”btn\”>\\&lt;/fieldset>\\&lt;/form>\\&lt;script>\/*通过score成绩的输入，动态修改meter的颜色*/\document.getElementById(\”score\”).oninput=function(){\document.getElementById(\”level\”).value=this.value;\}\\&lt;/script>\\&lt;/body> 说明： 1.\&lt;fieldset> 标签将表单内容的一部分打包，生成一组相关表单的字段。当一组表单元素放到 \&lt;fieldset> 标签内时，浏览器会以特殊方式来显示它们，它们可能有特殊的边界、3D 效果，或者甚至可创建一个子表单来处理这些元素。 2. legend 元素为 fieldset 元素定义标题（caption）。 十一：多媒体 1.音频播放：audio标签的使用: c. 属性： +————————+———-+———————————————————-+| [autoplay]{.underline} | autoplay | 如果出现该属性，则音频在就绪后马上播放。 |+========================+==========+==========================================================+| [controls]{.underline} | controls | 如果出现该属性，则向用户显示控件，比如播放按钮。 |+————————+———-+———————————————————-+| [loop]{.underline} | loop | 如果出现该属性，则每当音频结束时重新开始播放。 |+————————+———-+———————————————————-+| [preload]{.underline} | preload | 如果出现该属性，则音频在页面加载时进行加载，并预备播放。 || | | || | | 如果使用 \”autoplay\”，则忽略该属性。 |+————————+———-+———————————————————-+| [src]{.underline} | url | 要播放的音频的 URL。 |+————————+———-+———————————————————-+ d. 示例:播放音频 \\&lt;/audio> 视频播放：video标签的使用 a. 属性： +————————+———-+———————————————————-+| [autoplay]{.underline} | autoplay | 如果出现该属性，则视频在就绪后马上播放。 |+========================+==========+==========================================================+| [controls]{.underline} | controls | 如果出现该属性，则向用户显示控件，比如播放按钮。 |+————————+———-+———————————————————-+| [height]{.underline} | pixels | 设置视频播放器的高度。 |+————————+———-+———————————————————-+| [loop]{.underline} | loop | 如果出现该属性，则当媒介文件完成播放后再次开始播放。 |+————————+———-+———————————————————-+| [preload]{.underline} | preload | 如果出现该属性，则视频在页面加载时进行加载，并预备播放。 || | | || | | 如果使用 \”autoplay\”，则忽略该属性。 |+————————+———-+———————————————————-+| [src]{.underline} | url | 要播放的视频的 URL。 |+————————+———-+———————————————————-+| [width]{.underline} | pixels | 设置视频播放器的宽度。 |+————————+———-+———————————————————-+ b. 视频播放 \\&lt;/video> c. 说明：由于版权等原因，不同的浏览器可支持播放的格式是不一样的 十二：DOM扩展： 获取元素： a. document.getElementsByClassName (\’class\’) 通过类名获取元素，以类数组形式存在。getElementsByTagName b. document.querySelector(\’selector\’) 通过CSS选择器获取元素，符合匹配条件的第1个元素。 c. document.querySelectorAll(\’selector\’) 通过CSS选择器获取元素，以类数组形式存在。 类名操作： a. Node.classList.add(\’class\’) 添加class b. Node.classList.remove(\’class\’) 移除class c. Node.classList.toggle(\’class\’) 切换class，有则移除，无则添加 d. Node.classList.contains(\’class\’) 检测是否存在class 自定义属性： a) 在HTML5中我们可以自定义属性，其格式如下data-*=\”\”，例如：data-info=\”我是自定义属性\”，通过Node.dataset[\’info\’] 我们便可以获取到自定义的属性值。 b) 当我们如下格式设置时，则需要以驼峰格式才能正确获取：data-my-name=\”itcast\”，获取Node.dataset[\’myName\’] 小案例：tab标签页 练习重点： i. 获取元素的方式 ii. 自定义属性的使用 iii. 类名操作：如添加类样式，移除类样式 效果图 结构 \&lt;div class=\”tabs\”>\\&lt;div>\\&lt;a href=\”javascript:;\” data-target=\”local\”>国内新闻\&lt;/a>\\&lt;a href=\”javascript:;\” data-target=\”global\”>国际新闻\&lt;/a>\\&lt;a href=\”javascript:;\” data-target=\”sports\”>体育新闻\&lt;/a>\\&lt;a href=\”javascript:;\” data-target=\”funny\”>娱乐新闻\&lt;/a>\\&lt;/div> \&lt;section class=\”cont active\” id=\”local\”>\\&lt;ol>\\&lt;li>习近平向2名晋升为上将军官颁发命令状\&lt;/li>\\&lt;li>郭声琨了解指导公安消防部队抗洪工作\&lt;/li>\\&lt;li>媒体：曾任职中办的这位官员仕途有变\&lt;/li>\\&lt;li>广西警方端掉地下兵工厂缴获大批炮弹\&lt;/li>\\&lt;li>她完美诠释奇葩考题夺金牌\&lt;/li>\\&lt;li>中国奥运选手在里约多次遭抢劫\&lt;/li>\\&lt;/ol>\\&lt;/section>\\&lt;section class=\”cont active\” id=\”global\”>\\&lt;ol>\\&lt;li>河南再次发生矿难，死伤人数超过100\&lt;/li>\\&lt;li>禽流感次发生蔓延，温家宝指示\&lt;/li>\\&lt;li>南方大旱，农作物减产绝收面积上亩\&lt;/li>\\&lt;li>猪流感在广减产绝收发\&lt;/li>\\&lt;li>禽流感在全国多作物减产绝收面积上亩\&lt;/li>\\&lt;li>猪流感在广东群体性暴发\&lt;/li>\\&lt;/ol>\\&lt;/section>\\&lt;section class=\”cont\” id=\”sports\”>\\&lt;ol>\\&lt;li>河南再次发生矿难，死伤人数超过10\&lt;/li>\\&lt;li>禽流感在全国多处农作物农延，温家宝指示\&lt;/li>\\&lt;li>南方大旱，农作物减产绝收面积上亩\&lt;/li>\\&lt;li>猪流感在广东群体性暴发\&lt;/li>\\&lt;li>禽流感在全农作物继续蔓延，温家宝指示\&lt;/li>\\&lt;li>南方大农作物减产绝收面积上亩\&lt;/li>\\&lt;li>猪流感在广东群体性暴发\&lt;/li>\\&lt;/ol>\\&lt;/section>\\&lt;section class=\”cont\” id=\”funny\”>\\&lt;ol>\\&lt;li>福建发生血腥命案:两女遭割喉 1男孩被砍数刀\&lt;/li>\\&lt;li>四川原副省长李成云被查 5年前曾违纪又复出\&lt;/li>\\&lt;li>胡歌反对粉丝探班：以前请吃饭现在会黑脸\&lt;/li>\\&lt;li>曝郑爽爸爸歌厅撩妹 与女子勾肩搭背显亲密\&lt;/li>\\&lt;li>宜宾公安副局长无证驾驶出车祸 弃车离开现场\&lt;/li>\\&lt;li>国子监大街门匾现错字 已悬挂近10年(图)\&lt;/li>\\&lt;li>猪流感在广东群体性暴发\&lt;/li>\\&lt;/ol>\\&lt;/section>\\&lt;/div> js代码 \&lt;script>\(function(key){\//1.获取所有a标签\var allA=document.querySelector(\”.tabs\”).querySelector(\”div:first-child\”).querySelectorAll(\”a\”);\//初始化操作\for(var i=0;i\&lt;allA.length;i++){\if(i==key){\allA[i].classList.add(\”active\”);\var active=allA[i].dataset[\”target\”];\document.querySelector(\”#\”+active).style.display=\’block\’;\}\//2.循环遍历所有的a标签，为其添加点击事件\allA[i].onclick=function(){\//3.判断当前是否是当前已激活的页，如果是，则不进行处理\if(this.classList.contains(\”active\”)){\return;\}\//4.否则，则需要找到当前a标签对应的data-target属性，利用这个属性找到对应id的section进行样式的设置，让其显示\//4.1先移除之前a标签的active类样式\var aActive=document.querySelector(\”.active\”);\aActive.classList.remove(\”active\”);\//4.2让之前显示的section隐藏\var currentTarget=aActive.dataset[\”target\”]; document.querySelector(\”#\”+currentTarget) .style.display =\”none\”;\//4.3为其添加active样式\this.classList.add(\”active\”);\//4.4获取当前被点击的a标签的data-target属性\var value=this.dataset[\”target\”];\//4.5让对应id的section显示--添加active类样式即可\document.querySelector(\”#\”+value).style.display=\”block\”;\};\}\})(0);\\&lt;/script>]]></content>
      <categories>
        <category>HTML5和CSS3</category>
      </categories>
      <tags>
        <tag>HTML5和CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端非技术面试题]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%89%8D%E7%AB%AF%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发优化的一些常见办法(汇总)]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%8A%9E%E6%B3%95-%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[WEB前端开发常用的优化技巧汇总减少HTTP请求的次数或者减小请求数据的大小 页面中每发送一次HTTP请求，都需要完成请求加响应这个完整的HTTP事务，会消耗一些时间，也可能会导致HTTP链接通道的阻塞，为了提高页面的加载速度和运行的性能，我们应该减少HTTP的请求次数和减少请求内容的大小（请求的内容越大，消耗的时间越长）。 采用CSS雪碧图（CSS Sprit/CSS 图片精灵）技术，把一些小图合并在一张大图上，使用的时候通过背景图片定位，定位在具体的某一张小图上 12345678.pubBg&#123; background: url('../img/sprit.png') no-repeat; background-size: x y; /*和图片的大小保持一致*/&#125;.box&#123; background-position: x y; /*通过背景定位，定位到具体的位置，展示不同的图片即可*/&#125;&lt;div class="pubBg box"&gt;&lt;/div&gt; 真实项目中，我们最好把CSS或者JS文件进行合并压缩。尤其是在移动端开发的时候，如果css或者js内容不是很多，我们可以采取内嵌式，以此减少HTTP请求的次数，加快页面的加载速度 CSS合并成一个，JS最好也合并成一个 首先通过一些工具（例如：webpack）把合并后的CSS或者JS压缩成xxx.min.js，减少文件的大小 服务器端开启资源文件的GZIP压缩 通过一些自动化工具完成CSS以及JS的合并压缩，或者在完成LESS转CSS，ES6转ES5等操作，我们把这种自动化构建模式，称之为前端工程化开发 采用图片的懒加载技术，在页面开始加载的时候，不请求真实图片的地址，而是用默认图占位，当页面加载完成后，再根据相关的条件依次加载真实图片（减少页面首次加载HTTP请求的次数） 真实项目中，我们开始图片都不加载，页面首次加载完成，先把第一屏幕中可以看见的图片进行加载，随着页面的滚动，再把下面区域中能够呈现出来的图片进行加载 根据图片的懒加载技术，我们还可以扩充出数据的懒加载 开始加载页面的时候，我们只把首屏或者前两屏的数据从服务端进行请求（有些网站首屏数据是后台渲染好，整体返回给客户端呈现的） 当页面下拉，滚动到哪个区域，在把这个区域需要的数据进行请求（用请求回来的数据进行数据的绑定以及图片的延迟加载等） 分页展示技术采用的也是数据的懒加载思想实现的：如果我们请求获取很多的数据，我们最好分批请求，开始只请求第一页的数据，当用户点击第二页（微博是下拉到一定距离后，在请求第二页数据…）的时候在请求第二页的数据 对于不经常更新的数据，最好采用浏览器的304缓存做处理（主要由服务器端处理） 例如: 第一次请求CSS和JS下来，浏览器会把请求的内容缓存起来，如果做了304处理，用户再次请求CSS和JS，直接从缓存中读取，不需要再去服务器获取了（减少了HTTP请求的次数） 当用户强制刷新页面（CTRL+F5）或者当前缓存的CSS或者JS发生了变动，都会重新从服务器端拉取 … 对于客户端来讲，我们还可以基于localStorage来做一些本地存储，例如：第一次请求的数据或者不经常更新的CSS和JS，我们都可以把内容存储到本地，下一次页面的加载，我们从本地获取即可，我们设定一定的期限或者一些标识，可以控制在某个阶段重新从服务器获取 使用字体图标代替页面中的一些位图（图片），这样不仅做适配的时候方便，而且更加轻量级，而且减少了HTTP请求次数（类似于雪碧图） 如果当前页面中出现了Audio或者Video标签，我们最好设置他们的preload=none；当页面加载的时候，音视频资源不进行加载，播放的时候在进行加载（减少页面首次加载HTTP请求的次数） preload=auto；页面首次加载的时候就把音视频进行加载了 preload=metadata；页面首次加载的时候只把音视频资源的头部信息进行加载 在客户端和服务器端进行数据通信的时候，我们尽量采用JSON格式进行数据传输 [优势] JSON格式的数据，能够清晰明了的展示出数据结构，而且也方便我们获取和操作 相对于很早以前的XML传输，JSON格式的数据更加轻量级 客户端和服务器端都支持JSON数据的处理，处理起来非常的方便 在真实项目中，并不是所有的数据都要基于JSON，我们尽可能这样做，但是对于某些特殊需求（例如：文件流的传输或者文档传输），使用JSON就不合适了 采用CDN加速 CDN: 分布式（地域分布式） 关于编写代码时候的一些优化技巧 除了减少HTTP请求次数和大小可以优化性能，我们在编写代码的时候，可以进行一些优化，让页面的性能有所提升（有些不好的代码编写习惯，会导致页面性能消耗太大，例如：内存泄漏） 在编写JS代码的时候，尽量减少对DOM的操作 VUE和REACT框架在这方面处理的非常不错 在JS中操作DOM是一个非常消耗性能的事情，但是我们又不可避免的操作DOM，我们只能尽量减少对于他的操作 【操作DOM的弊端】 DOM存在映射机制（JS中的DOM元素对象和页面中的DOM结构是存在映射机制的，一改则都改），这种映射机制，是浏览器按照W3C标准完成对JS语言的构建和DOM的构建（其实就是构建了一个监听机制），操作DOM是同时要修改两个地方，相对于一些其他的JS编程来说是消耗性能的 页面中的DOM结构改变或者样式改变，会触发浏览器的回流（浏览器会把DOM结构重新进行计算，这个操作很耗性能）和重绘（把一个元素样式重新渲染） 编写代码的时候，更多使用的是异步编程 同步编程会导致：上面东西完不成，下面任务也做不了，我们开发的时候，可以把某一个区域模块都设置为异步编程，这样只要模块之间没有必然的先后顺序，都可以独立进行加载，不会受到上面模块的堵塞影响（用的不多） 尤其是AJAX数据请求，我们都要使用异步编程，最好是基于promise设计模式进行管理（项目中经常使用fetch，vue axios等插件来进行AJAX请求处理，因为这些插件中就是基于promise设计模式对ajax进行封装处理） 在真实项目中，我们尽量避免一次性循环过多数据（因为循环操作是同步编程），尤其是要避免while导致的死循环操作 CSS选择器优化 尽量减少标签选择器的使用 尽可能少使用ID选择器，多使用样式类选择器（通用性强） 减少选择器前面的前缀，例如：.headerBox .nav .left a{} (选择器是从右向左查找的) 避免使用CSS表达式 1234/*CSS表达式*/.box&#123; background-color:expression((new Data()).getHours()%2?'red':'blue')&#125; 减少页面中的冗余代码，尽可能提高方法的重复使用率：“低耦合高内聚” 最好CSS放在HEAD中，JS放在BODY尾部，让页面加载的时候，先加载CSS，在加载JS（先呈现页面，再给用户提供操作） JS中避免使用eval 性能消耗大 代码压缩后，容易出现代码执行错乱问题 JS中尽量减少闭包的使用 闭包会形成一个不销毁的栈内存，过多的栈内存累积会影响页面的性能 还会容易导致内存泄漏 闭包也有自己的优势：保护和保存，我们只能尽量减少，但不可避免 在做DOM事件绑定的时候，尽量避免一个个的事件绑定，而是采用性能更高的事件委托来实现 事件委托（事件代理） 把事件绑定给外层容器，当里面的后代元素相关行为被触发，外层容器绑定的方法也会被触发执行（冒泡传播机制导致），通过事件源是谁，我们做不同的操作即可 尽量使用CSS3动画代替JS动画，因为CSS3动画或者变形都开启了硬件加速，性能比JS动画好 编写JS代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性等 CSS中减少对滤镜的使用，页面中也减少对于FLASH的使用 关于页面的SEO优化技巧 页面中杜绝出现死链接（404页面），而且对于用户输入的一个错误页面，我们要引导到404提示页面中（服务器处理的） 避免浏览器中异常错误的抛出 尽可能避免代码出错 使用TRY CATCH做异常信息捕获 增加页面关键词优化]]></content>
      <categories>
        <category>HTTP和AJAX重点知识</category>
      </categories>
      <tags>
        <tag>HTTP和AJAX重点知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScriptWebApi基础详解1]]></title>
    <url>%2F2018%2F12%2F12%2FJavaScriptWebApi%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[Web APIWeb API介绍API的概念API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 任何开发语言都有自己的API API的特征输入和输出(I/O) API的使用方法(console.log()) Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) 此处的Web API特指浏览器提供的API(一组方法)，Web API在后面的课程中有其它含义 掌握常见的浏览器提供的API的调用方式MDN-Web API JavaScript的组成 ECMAScript - JavaScript的核心定义了javascript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 BOMBOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window注意：window下一个特殊的属性 window.name 对话框 alert() prompt() confirm() 页面加载事件 onload 1234window.onload = function () &#123; // 当页面加载完成执行 // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行&#125; onunload 123window.onunload = function () &#123; // 当用户退出页面时执行&#125; 定时器setTimeout()和clearTimeout()在指定的毫秒数到达之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒后执行，返回定时器的标示var timerId = setTimeout(function () &#123; console.log('Hello World');&#125;, 1000);// 取消定时器的执行clearTimeout(timerId); setInterval()和clearInterval()定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数 12345678// 创建一个定时器，每隔1秒调用一次var timerId = setInterval(function () &#123; var date = new Date(); console.log(date.toLocaleTimeString());&#125;, 1000);// 取消定时器的执行clearInterval(timerId); location对象location对象是window对象下的一个属性，时候的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 12345678910111213scheme://host:port/path?query#fragmentscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个&apos;/&apos;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用&apos;&amp;&apos;符号隔开，每个参数的名和值用&apos;=&apos;符号隔开。例如：name=zsfragment:信息片断 字符串，锚点. location有哪些成员？ 使用chrome的控制台查看 查MDN MDN 成员 assign()/reload()/replace() hash/host/hostname/search/href…… 案例解析URL中的query，并返回对象的形式 1234567891011121314151617function getQuery(queryStr) &#123; var query = &#123;&#125;; if (queryStr.indexOf('?') &gt; -1) &#123; var index = queryStr.indexOf('?'); queryStr = queryStr.substr(index + 1); var array = queryStr.split('&amp;'); for (var i = 0; i &lt; array.length; i++) &#123; var tmpArr = array[i].split('='); if (tmpArr.length === 2) &#123; query[tmpArr[0]] = tmpArr[1]; &#125; &#125; &#125; return query;&#125;console.log(getQuery(location.search));console.log(getQuery(location.href)); history对象 back() forward() go() navigator对象 userAgent 通过userAgent可以判断用户浏览器的类型 platform 通过platform可以判断浏览器所在的系统平台类型. DOMDOM的概念文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有VBScript、ActiveX、以及微软自家的DHTML格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。 DOM又称为文档树模型 文档：一个网页可以称为文档 节点：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 模拟文档树结构 12345678910111213141516171819202122232425262728293031323334353637383940function Element(option) &#123; this.id = option.id || ''; this.nodeName = option.nodeName || ''; this.nodeValue = option.nodeValue || ''; this.nodeType = 1; this.children = option.children || [];&#125;var doc = new Element(&#123; nodeName: 'html'&#125;);var head = new Element(&#123; nodeName: 'head'&#125;);var body = new Element(&#123; nodeName: 'body'&#125;)doc.children.push(head);doc.children.push(body);var div = new Element(&#123; nodeName: 'div', nodeValue: 'haha',&#125;);var p = new Element(&#123; nodeName: 'p', nodeValue: '段落'&#125;)body.children.push(div);body.children.push(p);function getChildren(ele) &#123; for(var i = 0; i &lt; ele.children.length; i++) &#123; var child = ele.children[i]; console.log(child.nodeName); getChildren(child); &#125;&#125;getChildren(doc); DOM经常进行的操作 获取元素 动态创建元素 对元素进行操作(设置其属性或调用其方法) 事件(什么时机做相应的操作) 获取页面元素##案例1.点击按钮弹出对话框2.点击按钮修改超链接的地址和热点文字3.点击(每个)图片弹出对话框4.点击图片设置自身宽和高5.点击按钮修改每个图片的title属性6.点击按钮显示哈哈(排他功能)7.点击按钮显示和隐藏div8.显示和隐藏二维码9.点击按钮修改所有p标签内容10.点击按钮修改所有文本框内容11.点击按钮切换图片12.点击超链接停止跳转页面13.点击小图显示大图14.美女相册15点击按钮选中性别和兴趣 为什么要获取页面元素例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作 根据id获取元素12345var div = document.getElementById('main');console.log(div);// 获取到的数据类型 HTMLDivElement，对象都是有类型的// HTMLDivElement &lt;-- HTMLElement &lt;-- Element &lt;-- Node &lt;-- EventTarget 注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用。 根据标签名获取元素12345var divs = document.getElementsByTagName('div');for (var i = 0; i &lt; divs.length; i++) &#123; var div = divs[i]; console.log(div);&#125; 根据name获取元素*12345var inputs = document.getElementsByName('hobby');for (var i = 0; i &lt; inputs.length; i++) &#123; var input = inputs[i]; console.log(input);&#125; 根据类名获取元素12345var mains = document.getElementsByClassName('main');for (var i = 0; i &lt; mains.length; i++) &#123; var main = mains[i]; console.log(main);&#125; 根据选择器获取元素12345678var text = document.querySelector('#text');console.log(text);var boxes = document.querySelectorAll('.box');for (var i = 0; i &lt; boxes.length; i++) &#123; var box = boxes[i]; console.log(box);&#125; 总结 12345678掌握 getElementById() getElementsByTagName()了解 getElementsByName() getElementsByClassName() querySelector() querySelectorAll() 事件事件：触发-响应机制 Event接口表示在DOM中发生的任何事件，一些是用户生成的（例如鼠标或键盘事件），而其他由API生成。 事件三要素 事件源:触发(被)事件的元素 事件类型:事件的触发方式(例如鼠标点击或键盘点击) 事件处理程序:事件触发后要执行的代码(函数形式) 事件的基本使用1234var box = document.getElementById('box');box.onclick = function() &#123; console.log('代码会在box被点击后执行'); &#125;; 案例 点击按钮弹出提示框 点击按钮修改元素的样式 属性操作非表单元素的属性href、title、id、src、className 123456var link = document.getElementById('link');console.log(link.href);console.log(link.title);var pic = document.getElementById('pic');console.log(pic.src); 案例： ​ 点击按钮，切换img标签里的图片 ​ 点击按钮显示隐藏div innerHTML和innerText 12345var box = document.getElementById('box');box.innerHTML = '我是文本&lt;p&gt;我会生成为标签&lt;/p&gt;';console.log(box.innerHTML);box.innerText = '我是文本&lt;p&gt;我不会生成为标签&lt;/p&gt;';console.log(box.innerText); HTML转义符 1234567&quot; &amp;quot;‘ &amp;apos;&amp; &amp;amp;&lt; &amp;lt; //less than 小于&gt; &amp;gt; // greater than 大于空格 &amp;nbsp;© &amp;copy; innerHTML和innerText的区别 innerText的兼容性处理 表单元素属性 value 用于大部分表单元素的内容获取(option除外) type 可以获取input标签的类型(输入框或复选框等) disabled 禁用属性 checked 复选框选中属性 selected 下拉菜单选中属性 案例 给文本框赋值，获取文本框的值 点击按钮禁用文本框 搜索文本框 检测用户名是否是3-6位，密码是否是6-8位，如果不满足要求高亮显示文本框 设置下拉框中的选中项 全选反选 自定义属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 与element.属性的区别: 上述三个方法用于获取任意的行内属性。 样式操作 使用style方式设置的样式显示在标签行内 1234var box = document.getElementById('box');box.style.width = '100px';box.style.height = '100px';box.style.backgroundColor = 'red'; 注意 通过样式属性设置宽高、位置的属性类型是字符串，需要加上px 类名操作 修改标签的className属性相当于直接修改标签的类名12var box = document.getElementById('box');box.className = 'clearfix'; 案例 开关灯 点击按钮变色 图片切换二维码案例 当前输入的文本框高亮显示 点击按钮改变div的大小和位置 列表隔行变色、高亮显示 京东商品展示 tab选项卡切换 创建元素的三种方式document.write()1document.write('新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;'); innerHTML12var box = document.getElementById('box');box.innerHTML = '新内容&lt;p&gt;新标签&lt;/p&gt;'; document.createElement()12var div = document.createElement('div');document.body.appendChild(div); 性能问题 innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。 可以借助字符串或数组的方式进行替换，再设置给innerHTML 优化后与document.createElement性能相近 案例 动态创建列表，高亮显示 根据数据动态创建表格 模拟百度搜索文本框 节点操作1234567891011var body = document.body;var div = document.createElement('div');body.appendChild(div);var firstEle = body.children[0];body.insertBefore(div,firstEle);body.removeChild(firstEle);var text = document.createElement('p');body.replaceChild(text, div); 案例： ​ 权限选择 节点层级重点讲父子属性，兄弟属性画图讲解 12345678var box = document.getElementById('box');console.log(box.parentNode);console.log(box.childNodes);console.log(box.children);console.log(box.nextSibling);console.log(box.previousSibling);console.log(box.firstChild);console.log(box.lastChild); 注意 childNodes和children的区别，childNodes获取的是子节点，children获取的是子元素 nextSibling和previousSibling获取的是节点，获取元素对应的属性是nextElementSibling和previousElementSibling获取的是元素 ​ nextElementSibling和previousElementSibling有兼容性问题，IE9以后才支持 总结 1234567891011节点操作，方法 appendChild() insertBefore() removeChild() replaceChild()节点层次，属性 parentNode childNodes children nextSibling/previousSibling firstChild/lastChild 事件详解注册/移除事件的三种方式123456789101112131415var box = document.getElementById('box');box.onclick = function () &#123; console.log('点击后执行');&#125;;box.onclick = null;box.addEventListener('click', eventCode, false);box.removeEventListener('click', eventCode, false);box.attachEvent('onclick', eventCode);box.detachEvent('onclick', eventCode);function eventCode() &#123; console.log('点击后执行');&#125; 兼容代码12345678910111213141516171819function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent)&#123; element.attachEvent('on' + type,fn); &#125; else &#123; element['on'+type] = fn; &#125;&#125;function removeEventListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, fn); &#125; else &#123; element['on'+type] = null; &#125;&#125; 事件的三个阶段 捕获阶段 当前目标阶段 冒泡阶段 事件对象.eventPhase属性可以查看事件触发时所处的阶段 事件对象的属性和方法 event.type 获取事件类型 clientX/clientY 所有浏览器都支持，窗口位置 pageX/pageY IE8以前不支持，页面位置 event.target || event.srcElement 用于获取触发事件的元素 event.preventDefault() 取消默认行为 案例 跟着鼠标飞的天使 鼠标点哪图片飞到哪里 获取鼠标在div内的坐标 阻止事件传播的方式 标准方式 event.stopPropagation(); IE低版本 event.cancelBubble = true; 标准中已废弃 常用的鼠标和键盘事件 onmouseup 鼠标按键放开时触发 onmousedown 鼠标按键按下触发 onmousemove 鼠标移动触发 onkeyup 键盘按键按下触发 onkeydown 键盘按键抬起触发 特效偏移量 offsetParent用于获取定位的父级元素 offsetParent和parentNode的区别 123456var box = document.getElementById('box');console.log(box.offsetParent);console.log(box.offsetLeft);console.log(box.offsetTop);console.log(box.offsetWidth);console.log(box.offsetHeight); 客户区大小12345var box = document.getElementById('box');console.log(box.clientLeft);console.log(box.clientTop);console.log(box.clientWidth);console.log(box.clientHeight); 滚动偏移12345var box = document.getElementById('box');console.log(box.scrollLeft)console.log(box.scrollTop)console.log(box.scrollWidth)console.log(box.scrollHeight) 案例 匀速动画函数 变速动画函数 回到顶部 无缝轮播图 模拟滚动条 拖拽案例 放大镜案例 附录元素的类型]]></content>
      <categories>
        <category>JavaScriptWebApi</category>
      </categories>
      <tags>
        <tag>JavaScriptWebApi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基础详解1]]></title>
    <url>%2F2018%2F12%2F12%2Fjavascript%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[JavaScript基础第一天重点内容变量的声明及使用数据类型类型转换运算符 课外提示1.敲代码用指法,指法配图，坚持一周者即可熟练2.码农不需要练就一阳指或者二指禅3.可以使用金山打字通，此处并非打广告,个人建议，天天敲代码，不停的反复的敲练习和作业，速度和基本功的快速提升奉劝各位:保护好自己的手控制自己的右手windows中的常用快捷键 浏览器说明浏览器是指可以显示网页服务器或者文件系统的HTML文件内容，并让用户与这些文件交互的一种软件。通俗的讲:可以显示页面的一个软件,国内网民计算机上常见的网页浏览器有，QQ浏览器、Internet Explorer、Firefox、Safari，Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、傲游浏览器、世界之窗浏览器等，浏览器是最经常使用到的客户端程序。常用的五大浏览器：chrome，firefox，Safari，ie，opera我们用chrome(谷歌浏览器) 网页、网站和应用程序网页：单独的一个页面网站：一些列相关的页面组成到一起应用程序：可以和用户产生交互，并实现某种功能。 演示JavaScript的强大http://impress.github.io/impress.js/http://naotu.baidu.com/https://codecombat.com/https://ide.codemao.cn/ 需要翻墙https://developers.google.com/blockly/blockly迷宫https://blockly-games.appspot.com blockly迷宫不需要翻墙https://blockly.uieee.com/ JavaScript介绍JavaScript是什么HTML CSS JavaScript 编程语言 流程控制 Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。Java和JavaScript的关系就像张雨和张雨生的关系，只是名字很像。 ​ Java 服务器端的编程语言 ​ JavaScript 运行在客户端(浏览器)的编程语言 JavaScript是一种运行在客户端 的脚本语言JavaScript的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 JavaScript最初的目的演示：http://baixiu.uieee.com/admin/login.php最初的目的是为了处理表单的验证操作。 JavaScript现在的意义(应用场景)JavaScript 发展到现在几乎无所不能。 网页特效 服务端开发(Node.js) 命令行工具(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) JavaScript和HTML、CSS的区别 HTML：提供网页的结构，提供网页中的内容 CSS: 用来美化网页 JavaScript: 可以用来控制网页内容，给网页增加动态的效果 JavaScript的组成 ECMAScript - JavaScript的核心ECMA 欧洲计算机制造联合会 网景：JavaScript 微软：JScript 定义了JavaScript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 JavaScript初体验CSS：行内样式、嵌入样式、外部样式 JavaScript的书写位置 写在行内 1&lt;input type="button" value="按钮" onclick="alert('Hello World')" /&gt; 写在script标签中 12345&lt;head&gt; &lt;script&gt; alert('Hello World!'); &lt;/script&gt;&lt;/head&gt; 写在外部js文件中，在页面引入 1&lt;script src="main.js"&gt;&lt;/script&gt; 注意点 引用外部js文件的script标签中不可以写JavaScript代码 计算机组成软件 应用软件：浏览器(Chrome/IE/Firefox)、QQ、Sublime、Word 系统软件：Windows、Linux、mac OSX 硬件 三大件：CPU、内存、硬盘 – 主板 输入设备：鼠标、键盘、手写板、摄像头等 输出设备：显示器、打印机、投影仪等 变量什么是变量 什么是变量 变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量 使用变量可以方便的获取或者修改内存中的数据 如何使用变量 var声明变量 1var age; 变量的赋值 12var age;age = 18; 同时声明多个变量 123var age, name, sex;age = 10;name = 'zs'; 同时声明多个变量并赋值 1var age = 10, name = 'zs'; 变量在内存中的存储1var age = 18; 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，例如：for、while。 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 下面哪些变量名不合法 123456789a 1age1818agename$name_sex&amp;sextheworld theWorld 案例 交换两个变量的值 不使用临时变量，交换两个数值变量的值 数据类型简单数据类型Number、String、Boolean、Undefined、Null Number类型 数值字面量：数值的固定值的表示法 110 1024 60.5 进制 123456789101112十进制 var num = 9; 进行算数计算时，八进制和十六进制表示的数值最终都将被转换成十进制数值。十六进制 var num = 0xA; 数字序列范围：0~9以及A~F八进制 var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 数字序列范围：0~7 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析 浮点数 浮点数的精度问题 123456浮点数 var n = 5e-324; // 科学计数法 5乘以10的-324次方 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数 var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); 不要判断两个浮点数是否相等 数值范围 1234最小值：Number.MIN_VALUE，这个值为： 5e-324最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308无穷大：Infinity无穷小：-Infinity 数值判断 NaN：not a number NaN 与任何值都不相等，包括他本身 isNaN: is not a number String类型‘abc’ “abc” 字符串字面量 ‘程序猿’，’程序媛’, “黑马程序猿” ​ 思考：如何打印以下字符串。我是一个”正直”的人我很喜欢”黑马’程序猿’” 转义符 字符串长度 length属性用来获取字符串的长度 12var str = '黑马程序猿 Hello World';console.log(str.length); 字符串拼接 字符串拼接使用 + 连接 12345console.log(11 + 11);console.log('hello' + ' world');console.log('100' + '100');console.log('11' + 11);console.log('male:' + true); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 Boolean类型 Boolean字面量： true和false，区分大小写 计算机内部存储：true为1，false为0 Undefined和Null undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined null表示一个空，变量的值如果想为null，必须手动设置 复杂数据类型​ Object 获取变量的类型typeof 12var age = 18;console.log(typeof age); // 'number' 字面量在源代码中一个固定值的表示法。 数值字面量：8, 9, 10 字符串字面量：’黑马程序员’, “大前端” 布尔字面量：true，false 注释单行注释用来描述下面一个或多行代码的作用 12// 这是一个变量var name = 'hm'; 多行注释用来注释多条代码 12345/*var age = 18;var name = 'zs';console.log(name, age);*/ 数据类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的 转换成字符串类型 toString() 12var num = 5;console.log(num.toString()); String() 1String()函数存在的意义：有些值没有toString()，这个时候可以使用String()。比如：undefined和null 拼接字符串方式 num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 转换成数值类型 Number() 1Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN parseInt() 12var num1 = parseInt("12.3abc"); // 返回12，如果第一个字符是数字会解析知道遇到非数字结束var num2 = parseInt("abc123"); // 返回NaN，如果第一个字符不是数字或者符号就返回NaN parseFloat() 1234parseFloat()把字符串转换成浮点数parseFloat()和parseInt非常相似，不同之处在与 parseFloat会解析第一个. 遇到第二个.或者非数字结束 如果解析的内容里只有整数，解析成整数 +，-0等运算 1234var str = '500';console.log(+str); // 取正console.log(-str); // 取负console.log(str - 0); 转换成布尔类型 Boolean() 0 ‘’(空字符串) null undefined NaN 会转换成false 其它都会转换成true 操作符运算符 operator 5 + 6 表达式 组成 操作数和操作符，会有一个结果 算术运算符1+ - * / % 一元运算符一元运算符：只有一个操作数的运算符 5 + 6 两个操作数的运算符 二元运算符 ++ 自身加1 – 自身减1 前置++ 12345var num1 = 5;++ num1; var num2 = 6;console.log(num1 + ++ num2); 后置++ 1234var num1 = 5;num1 ++; var num2 = 6 console.log(num1 + num2 ++); 猜猜看 1234var a = 1; var b = ++a + ++a; console.log(b); var a = 1; var b = a++ + ++a; console.log(b); var a = 1; var b = a++ + a++; console.log(b); var a = 1; var b = ++a + a++; console.log(b); 总结前置++：先加1，后参与运算后置++：先参与运算，后加1上面两个理解后，下面两个自通前置– ：先减1，后参与运算后置– ：先参与运算，后减1​ 逻辑运算符(布尔运算符)&amp;&amp; 与 两个操作数同时为true，结果为true，否则都是false || 或 两个操作数有一个为true，结果为true，否则为false ! 非 取反 关系运算符(比较运算符)&lt; &gt; &gt;= &lt;= == != === !== 12345==与===的区别：==只进行值得比较，===类型和值同时相等，则相等var result = '55' == 55; // truevar result = '55' === 55; // false 值相等，类型不相等var result = 55 === 55; // true 赋值运算符= += -= *= /= %=123例如：var num = 0;num += 5; //相当于 num = num + 5; 运算符的优先级优先级从高到底 1. () 优先级最高 2. 一元运算符 ++ -- ! 3. 算数运算符 先* / % 后 + - 4. 关系运算符 &gt; &gt;= &lt; &lt;= 5. 相等运算符 == != === !== 6. 逻辑运算符 先&amp;&amp; 后|| 7. 赋值运算符 12345// 练习1：4 &gt;= 6 || '人' != '阿凡达' &amp;&amp; !(12 * 2 == 144) &amp;&amp; true// 练习2：var num = 10;5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === '22' 表达式和语句表达式 一个表达式可以产生一个值，有可能是运算、函数调用、有可能是字面量。表达式可以放在任何需要值的地方。 语句 语句可以理解为一个行为，循环语句和判断语句就是典型的语句。一个程序有很多个语句组成，一般情况下;分割一个一个的语句 流程控制 程序的三种基本结构 顺序结构 从上到下执行的代码就是顺序结构 程序默认就是由上到下顺序执行的 分支结构根据不同的情况，执行对应代码 循环结构循环结构：重复做一件事情 分支结构if语句语法结构 12345678910111213141516171819if (/* 条件表达式 */) &#123; // 执行语句&#125;if (/* 条件表达式 */)&#123; // 成立执行语句&#125; else &#123; // 否则执行语句&#125;if (/* 条件1 */)&#123; // 成立执行语句&#125; else if (/* 条件2 */)&#123; // 成立执行语句&#125; else if (/* 条件3 */)&#123; // 成立执行语句&#125; else &#123; // 最后默认执行语句&#125; 案例：​ 求两个数的最大数​ 判断一个数是偶数还是奇数​ 分数转换，把百分制转换成ABCDE &lt;60 E 60-70 D 70-80 C 80-90 B 90 - 100 A作业：​ 判断一个年份是闰年还是平年​ 闰年：能被4整除，但不能被100整除的年份 或者 能被400整除的年份​ 判断一个人的年龄是否满18岁(是否成年) 三元运算符表达式1 ? 表达式2 : 表达式3 是对if……else语句的一种简化写法 案例：​ 是否年满18岁​ 从两个数中找最大值 switch语句语法格式:123456789101112131415161718switch (expression) &#123; case 常量1: 语句; break; case 常量2: 语句; break; case 常量3: 语句; break; … case 常量n: 语句; break; default: 语句; break;&#125; break可以省略，如果省略，代码会继续执行下一个case switch 语句在比较值时使用的是全等操作符, 因此不会发生类型转换（例如，字符串&apos;10&apos; 不等于数值 10） 案例：​ 显示星期几​ 素质教育（把分数变成ABCDE）千万不要写100个case哟 布尔类型的隐式转换流程控制语句会把后面的值隐式转换成布尔类型 转换为true 非空字符串 非0数字 true 任何对象 转换成false 空字符串 0 false null undefined 12// 结果是什么？var a = !!'123'; 案例12345var message;// 会自动把message转换成falseif (message) &#123; // todo...&#125; 循环结构 在javascript中，循环语句有三种，while、do..while、for循环。 while语句基本语法： 12345// 当循环条件为true时，执行循环体，// 当循环条件为false时，结束循环。while (循环条件) &#123; //循环体&#125; 代码示例： 123456789101112// 计算1-100之间所有数的和// 初始化变量var i = 1;var sum = 0;// 判断条件while (i &lt;= 100) &#123; // 循环体 sum += i; // 自增 i++;&#125;console.log(sum); 案例：​ 打印100以内 7的倍数​ 打印100以内所有偶数​ 打印100以内所有偶数的和作业：​ 打印100以内的奇数​ 打印100以内的奇数的和 do…while语句 do..while循环和while循环非常像，二者经常可以相互替代，但是do..while的特点是不管条件成不成立，都会执行一次。 基础语法： 123do &#123; // 循环体;&#125; while (循环条件); 代码示例： 1234567// 初始化变量var i = 1;var sum = 0;do &#123; sum += i;//循环体 i++;//自增&#125; while (i &lt;= 100);//循环条件 案例： 12求100以内所有3的倍数的和使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):&quot;，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 for语句 while和do…while一般用来解决无法确认次数的循环。for循环一般在循环次数确定的时候比较方便 for循环语法： 1234// for循环的表达式之间用的是;号分隔的，千万不要写成,for (初始化表达式1; 判断表达式2; 自增表达式3) &#123; // 循环体4&#125; 执行顺序：1243 —- 243 —–243(直到循环条件变成false) 初始化表达式 判断表达式 自增表达式 循环体 案例： 123456789101112131415161718192021222324252627282930313233343536打印1-100之间所有数求1-100之间所有数的和求1-100之间所有数的平均值求1-100之间所有偶数的和同时求1-100之间所有偶数和奇数的和打印正方形// 使用拼字符串的方法的原因// console.log 输出重复内容的问题// console.log 默认输出内容介绍后有换行var start = &apos;&apos;;for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; start += &apos;* &apos;; &#125; start += &apos;\n&apos;;&#125;console.log(start);打印直角三角形var start = &apos;&apos;;for (var i = 0; i &lt; 10; i++) &#123; for (var j = i; j &lt; 10; j++) &#123; start += &apos;* &apos;; &#125; start += &apos;\n&apos;;&#125;console.log(start);打印9*9乘法表var str = &apos;&apos;;for (var i = 1; i &lt;= 9; i++) &#123; for (var j = i; j &lt;=9; j++) &#123; str += i + &apos; * &apos; + j + &apos; = &apos; + i * j + &apos;\t&apos;; &#125; str += &apos;\n&apos;;&#125;console.log(str); 作业： 1234567求1-100之间所有数的乘积求1-100之间所有奇数的和计算1-100之间能3整除的数的和计算1-100之间不能被7整除的数的和// 讲解思路。如果不会写程序，可以先把数学公式准备好本金10000元存入银行，年利率是千分之三，每过1年，将本金和利息相加作为新的本金。计算5年后，获得的本金是多少？有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？（兔子的规律为数列，1，1，2，3，5，8，13，21） continue和break break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 案例： 12求整数1～100的累加值，但要求碰到个位为3的数则停止累加求整数1～100的累加值，但要求跳过所有个位为3的数 作业： 求1-100之间不能被7整除的整数的和（用continue）求200-300之间所有的奇数的和（用continue）求200-300之间第一个能被7整数的数（break） 调试 过去调试JavaScript的方式 alert() console.log() 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤 1浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 调试中的相关操作 123Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。F10: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 tips: 监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。 数组为什么要学习数组 之前学习的数据类型，只能存储一个值(比如：Number/String。我们想存储班级中所有学生的姓名，此时该如何存储？ 数组的概念 所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组的定义 数组是一个有序的列表，可以在数组中存放任意的数据，并且数组的长度可以动态的调整。 通过数组字面量创建数组 1234567891011// 创建一个空数组var arr1 = []; // 创建一个包含3个数值的数组，多个数组项以逗号隔开var arr2 = [1, 3, 4]; // 创建一个包含2个字符串的数组var arr3 = ['a', 'c']; // 可以通过数组的length属性获取数组的长度console.log(arr3.length);// 可以设置length属性改变数组中元素的个数arr3.length = 0; 获取数组元素数组的取值 123456// 格式：数组名[下标] 下标又称索引// 功能：获取数组对应下标的那个值，如果下标不存在，则返回undefined。var arr = ['red',, 'green', 'blue'];arr[0]; // redarr[2]; // bluearr[3]; // 这个数组的最大下标为2,因此返回undefined 遍历数组 遍历：遍及所有，对数组的每一个元素都访问一次就叫遍历。 数组遍历的基本语法： 123for(var i = 0; i &lt; arr.length; i++) &#123; // 数组遍历的固定结构&#125; 数组中新增元素数组的赋值 1234567// 格式：数组名[下标/索引] = 值;// 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。var arr = ["red", "green", "blue"];// 把red替换成了yellowarr[0] = "yellow";// 给数组新增加了一个pink的值arr[3] = "pink"; 案例123456求一组数中的所有数的和和平均值求一组数中的最大值和最小值，以及所在位置将字符串数组用|或其他符号分割要求将数组中的0项去掉，将不为0的值存入一个新的数组，生成新的数组翻转数组冒泡排序，从小到大 函数为什么要有函数 如果要在多个地方求1-100之间所有数的和，应该怎么做？ 什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名），在后续开发中可以反复调用 函数的作用就是封装一段代码，将来可以重复使用 函数的定义 函数声明 123function 函数名()&#123; // 函数体&#125; 函数表达式 123var fn = function() &#123; // 函数体&#125; 特点： 函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。函数一般都用来干一件事情，需用使用动词+名词，表示做一件事情 tellStory sayHello等 函数的调用 调用函数的语法： 1函数名(); 特点： 函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log("吃了没？");&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法： 12345678// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参...)&#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;//x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 案例 求1-n之间所有数的和 求n-m之间所有数额和 圆的面积 求2个数中的最大值 求3个数中的最大值 判断一个数是否是素数 函数的返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参...)&#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3); 函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。 返回值详解：​ 如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined​ 如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值​ 如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined​ 函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。​​ 推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。 案例 求阶乘 求1!+2!+3!+….+n! 求一组数中的最大值 求一组数中的最小值 arguments的使用 JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性。也就是说所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有的实参。arguments是一个伪数组，因此及可以进行遍历 案例12求任意个数的最大值求任意个数的和 案例12345求斐波那契数列Fibonacci中的第n个数是多少？ 1 1 2 3 5 8 13 21...翻转数组，返回一个新数组对数组排序，从小到大输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]输入某年某月某日，判断这一天是这一年的第几天？ 函数其它匿名函数 匿名函数：没有名字的函数 匿名函数如何使用： 将匿名函数赋值给一个变量，这样就可以通过变量进行调用 匿名函数自调用 关于自执行函数（匿名函数自调用）的作用：防止全局变量污染。 自调用函数 匿名函数不能通过直接调用来执行，因此可以通过匿名函数的自调用的方式来执行123(function () &#123; alert(123);&#125;)(); 函数是一种数据类型12function fn() &#123;&#125;console.log(typeof fn); 函数作为参数 因为函数也是一种类型，可以把函数作为两一个函数的参数，在两一个函数中调用 函数做为返回值 因为函数是一种类型，所以可以把函数可以作为返回值从函数内部返回，这种用法在后面很常见。 1234567function fn(b) &#123; var a = 10; return function () &#123; alert(a+b); &#125;&#125;fn(15)(); 代码规范1.命名规范 2.变量规范 var name = &apos;zs&apos;; 3.注释规范 // 这里是注释 4.空格规范 5.换行规范 var arr = [1, 2, 3, 4]; if (a &gt; b) { } for(var i = 0; i &lt; 10; i++) { } function fn() { } 作用域作用域：变量可以起作用的范围 全局变量和局部变量 全局变量 ​在任何地方都可以访问到的变量就是全局变量，对应全局作用域 局部变量 ​只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域) 12不使用var声明的变量是全局变量，不推荐使用。变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁 块级作用域任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。在es5之前没有块级作用域的的概念,只有函数作用域，现阶段可以认为JavaScript没有块级作用域 词法作用域变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 12345678910var num = 123;function foo() &#123; console.log( num );&#125;foo();if ( false ) &#123; var num = 123;&#125;console.log( num ); // undefiend 作用域链只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 1234567891011// 案例1：function f1() &#123; function f2() &#123; &#125;&#125;var num = 456;function f3() &#123; function f4() &#123; &#125;&#125; 12345678910// 案例2function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 预解析 JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 先提升var，在提升function JavaScript的执行过程 12345678910111213var a = 25;function abc ()&#123; alert(a);//undefined var a = 10;&#125;abc();// 如果变量和函数同名的话，函数优先console.log(a);function a() &#123; console.log('aaaaa');&#125;var a = 1;console.log(a); 全局解析规则函数内部解析规则变量提升 变量提升 定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。 函数提升 JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面 123456789101112131415161718192021222324252627// 1、-----------------------------------var num = 10;fun();function fun() &#123; console.log(num); var num = 20;&#125;//2、-----------------------------------var a = 18;f1();function f1() &#123; var b = 9; console.log(a); console.log(b); var a = '123';&#125;// 3、-----------------------------------f1();console.log(c);console.log(b);console.log(a);function f1() &#123; var a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125; 对象为什么要有对象1234567function printPerson(name, age, sex....) &#123;&#125;// 函数的参数如果特别多的话，可以使用对象简化function printPerson(person) &#123; console.log(person.name); ……&#125; 什么是对象12345现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。举例： 一部车，一个手机车是一类事物，门口停的那辆车才是对象 特征：红色、四个轮子 行为：驾驶、刹车 JavaScript中的对象123456JavaScript中的对象其实就是生活中对象的一个抽象JavaScript的对象是无序属性的集合。 其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。对象的行为和特征 特征---属性 行为---方法 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。 对象字面量 字面量：11 ‘abc’ true [] {}等 12345678var o = &#123; name: 'zs, age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; 思考： 1如何把学生对象、老师对象、英雄对象改写成字面量的方式 对象创建方式 对象字面量 12345678var o = &#123; name: 'zs', age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; new Object()创建对象 1234567var person = new Object(); person.name = 'lisi'; person.age = 35; person.job = 'actor'; person.sayHi = function()&#123; console.log('Hello,everyBody');&#125; 工厂函数创建对象 1234567891011function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log('Hello,everyBody'); &#125; return person;&#125;var p1 = createPerson('张三', 22, 'actor'); 自定义构造函数 123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayHi = function()&#123; console.log('Hello,everyBody'); &#125;&#125;var p1 = new Person('张三', 22, 'actor'); 属性和方法如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征 如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能 new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 this详解JavaScript中的this指向问题，有时候会让人难以捉摸，随着学习的深入，我们可以逐渐了解 现在我们需要掌握函数内部的this几个特点 1. 函数在定义的时候this是不确定的，只有在调用的时候才可以确定 2. 一般函数直接执行，内部this指向全局window 3. 函数作为一个对象的方法，被该对象所调用，那么this指向的是该对象 4. 构造函数中的this其实是一个隐式对象，类似一个初始化的模型，所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，从而实现实例化 对象的使用遍历对象的属性 通过for..in语法可以遍历一个对象 1234567var obj = &#123;&#125;;for (var i = 0; i &lt; 10; i++) &#123; obj[i] = i * 2;&#125;for(var key in obj) &#123; console.log(key + "==" + obj[key]);&#125; 删除对象的属性1234567function fun() &#123; this.name = 'mm';&#125;var obj = new fun(); console.log(obj.name); // mm delete obj.name;console.log(obj.name); // undefined 简单类型和复杂类型的区别 基本类型又叫做值类型，复杂类型又叫做引用类型 值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。 引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。 堆和栈 123堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收，分配方式倒是类似于链表。 注意：JavaScript中没有堆和栈的概念，此处我们用堆和栈来讲解，目的方便理解和方便以后的学习。 基本类型在内存中的存储 复杂类型在内存中的存储 基本类型作为函数的参数 复杂类型作为函数的参数 123456789101112131415// 下面代码输出的结果function Person(name,age,salary) &#123; this.name = name; this.age = age; this.salary = salary;&#125;function f1(person) &#123; person.name = "ls"; person = new Person("aa",18,10);&#125;var p = new Person("zs",18,1000);console.log(p.name);f1(p);console.log(p.name); 思考： 1234567891011121314151617181920212223242526272829303132//1. var num1 = 10;var num2 = num1;num1 = 20;console.log(num1);console.log(num2);//2. var num = 50;function f1(num) &#123; num = 60; console.log(num);&#125;f1(num);console.log(num);//3. var num1 = 55;var num2 = 66;function f1(num, num1) &#123; num = 100; num1 = 100; num2 = 100; console.log(num); console.log(num1); console.log(num2);&#125;f1(num1, num2);console.log(num1);console.log(num2);console.log(num); 内置对象JavaScript中的对象分为3种：内置对象、浏览器对象、自定义对象 JavaScript 提供多个内置对象：Math/Array/Number/String/Boolean… 对象只是带有属性和方法的特殊数据类型。 学习一个内置对象的使用，只要学会其常用的成员的使用（通过查文档学习） 可以通过MDN/W3C来查询 内置对象的方法很多，我们只需要知道内置对象提供的常用方法，使用的时候查询文档。 MDNMozilla 开发者网络（MDN）提供有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 MDN 通过查询MDN学习Math对象的random()方法的使用 如何学习一个方法？ 方法的功能 参数的意义和类型 返回值意义和类型 demo进行测试 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 演示：Math.PI、Math.random()、Math.floor()/Math.ceil()、Math.round()、Math.abs() 、Math.max() 123456789Math.PI // 圆周率Math.random() // 生成随机数Math.floor()/Math.ceil() // 向下取整/向上取整Math.round() // 取整，四舍五入Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值Math.sin()/Math.cos() // 正弦/余弦Math.power()/Math.sqrt() // 求指数次幂/求平方根 案例 求10-20之间的随机数 随机生成颜色RGB 模拟实现max()/min() Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 12345678// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数Date构造函数的参数1. 毫秒数 1498099000356 new Date(1498099000356)2. 日期格式字符串 '2015-5-1' new Date('2015-5-1')3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 123456789var now = new Date();// valueOf用于获取对象的原始值console.log(date.valueOf()) // HTML5中提供的方法，有兼容性问题var now = Date.now(); // 不支持HTML5的浏览器，可以用下面这种方式var now = + new Date(); // 调用 Date对象的valueOf() 日期格式化方法 1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分 123456789getTime() // 返回毫秒数和valueOf()结果一样，valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718function formatDate(d) &#123; //如果date不是日期对象，返回 if (!date instanceof Date) &#123; return; &#125; var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? '0' + month : month; date = date &lt; 10 ? '0' + date : date; hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute:minute; second = second &lt; 10 ? '0' + second:second; return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125; 计算时间差，返回相差的天/时/分/秒 123456789101112131415function getInterval(start, end) &#123; var day, hour, minute, second, interval; interval = end - start; interval /= 1000; day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125; Array对象 创建数组对象的两种方式 字面量方式 new Array() 1234567891011121314// 1. 使用构造函数创建数组对象// 创建了一个空数组var arr = new Array();// 创建了一个数组，里面存放了3个字符串var arr = new Array('zs', 'ls', 'ww');// 创建了一个数组，里面存放了4个数字var arr = new Array(1, 2, 3, 4);// 2. 使用字面量创建数组对象var arr = [1, 2, 3];// 获取数组中元素的个数console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()/valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组对象本身 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() 123456789101112131415161718192021// 1 栈操作(先进后出)push()pop() //取出数组中的最后一项，修改length属性// 2 队列操作(先进先出)push()shift() //取出数组中的第一个元素，修改length属性unshift() //在数组最前面插入项，返回数组的长度// 3 排序方法reverse() //翻转数组sort(); //即使是数组sort也是根据字符，从小到大排序// 带参数的sort是如何实现的？// 4 操作方法concat() //把参数拼接到当前数组slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目)// 5 位置方法indexOf()、lastIndexOf() //如果没找到返回-1// 6 迭代方法 不会修改原数组(可选)every()、filter()、forEach()、map()、some()// 7 方法将数组的所有元素连接到一个字符串中。join() 清空数组 123456// 方式1 推荐 arr = [];// 方式2 arr.length = 0;// 方式3arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 12345678910111213141516function myJoin(array, seperator) &#123; seperator = seperator || ','; array = array || []; if (array.length == 0)&#123; return ''; &#125; var str = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; str += seperator + array[i]; &#125; return str;&#125;var array = [6, 3, 5, 6, 7, 8, 0];console.log(myJoin(array, '-'));console.log(array.join('-')) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 123456789101112131415161718// 方式1var array = [1500,1200,2000,2100,1800];var tmpArray = [];for (var i = 0; i &lt; array.length; i++) &#123; if(array[i] &lt; 2000) &#123; tmpArray.push(array[i]); &#125;&#125;console.log(tmpArray);// 方式2var array = [1500, 1200, 2000, 2100, 1800];array = array.filter(function (item, index) &#123; if (item &lt; 2000) &#123; return true; &#125; return false;&#125;);console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 1234567var array = ['c', 'a', 'z', 'a', 'x', 'a'];do &#123; var index = array.indexOf('a',index + 1); if (index != -1)&#123; console.log(index); &#125;&#125; while (index &gt; 0); 编写一个方法去掉一个数组的重复元素 12345678910111213141516171819202122232425var array = ['c', 'a', 'z', 'a', 'x', 'a'];function clear() &#123; var o = &#123;&#125;; for (var i = 0; i &lt; array.length; i++) &#123; var item = array[i]; if (o[item]) &#123; o[item]++; &#125;else&#123; o[item] = 1; &#125; &#125; var tmpArray = []; for(var key in o) &#123; if (o[key] == 1) &#123; tmpArray.push(key); &#125;else&#123; if(tmpArray.indexOf(key) == -1)&#123; tmpArray.push(key); &#125; &#125; &#125; returm tmpArray;&#125;console.log(clear(array)); 基本包装类型为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean 123456789// 下面代码的问题？// s1是基本类型，基本类型是没有方法的var s1 = 'zhangsan';var s2 = s1.substring(5);// 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于：var s1 = new String('zhangsan');var s2 = s1.substring(5);s1 = null; 1234567// 创建基本包装类型的对象var num = 18; //数值，基本类型var num = Number('18'); //类型转换var num = new Number(18); //基本包装类型，对象// Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如：var b1 = new Boolean(false);var b2 = b1 &amp;&amp; true; // 结果是什么 String对象 字符串的不可变 12345var str = 'abc';str = 'hello';// 当重新给str赋值的时候，常量'abc'不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 1234var str = new String('Hello World');// 获取字符串中字符的个数console.log(str.length); 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 1234567891011121314151617181920212223// 1 字符方法charAt() //获取指定位置处字符charCodeAt() //获取指定位置处字符的ASCII码str[0] //HTML5，IE8+支持 和charAt()等效// 2 字符串操作方法concat() //拼接字符串，等效于+，+更常用slice() //从start位置开始，截取到end位置，end取不到substring() //从start位置开始，截取到end位置，end取不到substr() //从start位置开始，截取length个字符// 3 位置方法indexOf() //返回指定内容在元字符串中的位置lastIndexOf() //从后往前找，只找第一个匹配的// 4 去除空白 trim() //只能去除字符串前后的空白// 5 大小写转换方法to(Locale)UpperCase() //转换大写to(Locale)LowerCase() //转换小写// 6 其它search()replace()split()fromCharCode()// String.fromCharCode(101, 102, 103); //把ASCII码转换成字符串 案例 截取字符串”我爱中华人民共和国”，中的”中华” 123var s = "我爱中华人民共和国";s = s.substr(2,2);console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 123456789var s = 'abcoefoxyozzopp';var array = [];do &#123; var index = s.indexOf('o', index + 1); if (index != -1) &#123; array.push(index); &#125;&#125; while (index &gt; -1);console.log(array); 把字符串中所有的o替换成! 1234567var s = 'abcoefoxyozzopp';do &#123; s = s.replace('o', '');&#125; while (s.indexOf('o') &gt; -1);console.log(s);console.log(s.replace(/o/ig, '')); 判断一个字符串中出现次数最多的字符，统计这个次数 1234567891011121314151617181920212223var s = 'abcoefoxyozzopp';var o = &#123;&#125;;for (var i = 0; i &lt; s.length; i++) &#123; var item = s.charAt(i); if (o[item]) &#123; o[item] ++; &#125;else&#123; o[item] = 1; &#125;&#125;var max = 0;var char ;for(var key in o) &#123; if (max &lt; o[key]) &#123; max = o[key]; char = key; &#125;&#125;console.log(max);console.log(char); 作业12345678给定一个字符串如：“abaasdffggghhjjkkgfddsssss3444343”问题如下： 1、 字符串的长度 2、 取出指定位置的字符，如：0,3,5,9等 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法 5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数 7、 遍历字符串，并将遍历出的字符两头添加符号“@”输出至当前的文档页面。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级1]]></title>
    <url>%2F2018%2F12%2F12%2FJavaScript%E9%AB%98%E7%BA%A71%2F</url>
    <content type="text"><![CDATA[JavaScript 高级 课程介绍课程大纲在线地址：JavaScript 高级 目标 理解面向对象开发思想 掌握 JavaScript 面向对象开发相关模式 掌握在 JavaScript 中使用正则表达式 案例演示 贪吃蛇 基本概念复习 由于 JavaScript 高级还是针对 JavaScript 语言本身的一个进阶学习，所以在开始之前我们先对以前所学过的 JavaScript 相关知识点做一个快速复习总结。 重新介绍 JavaScriptJavaScript 是什么 解析执行：轻量级解释型的，或是 JIT 编译型的程序设计语言 语言特点：动态，头等函数 (First-class Function) 又称函数是 JavaScript 中的一等公民 执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境 但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js 编程范式：基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格 JavaScript 与浏览器的关系 JavaScript 的组成 组成部分 说明 Ecmascript 描述了该语言的语法和基本对象 DOM 描述了处理网页内容的方法和接口 BOM 描述了与浏览器进行交互的方法和接口 JavaScript 可以做什么 Any application that can be written in JavaScript, will eventually be written in JavaScript.凡是能用 JavaScript 写出来的，最终都会用 JavaScript 写出来 知乎 - JavaScript 能做什么，该做什么？ 最流行的编程语言 JavaScript 能做什么？ JavaScript 发展历史 JavaScript 标准参考教程 - JavaScript 语言的历史 JavaScript 的诞生 JavaScript 与 Ecmascript 的关系 JavaScript 与 Java 的关系 JavaScript 的版本 JavaScript 周边大事记 小结基本概念 本小节快速过即可，主要是对学过的内容做知识点梳理。 语法 区分大小写 标识符 注释 严格模式 语句 关键字和保留字 变量 数据类型 typeof 操作符 Undefined Null Boolean Number String Object 操作符 流程控制语句 函数 JavaScript 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。 基本类型（值类型） Undefined Null Boolean Number String 复杂类型（引用类型） Object Array Date RegExp Function 基本包装类型 Boolean Number String 单体内置对象 Global Math 类型检测 typeof instanceof Object.prototype.toString.call() 值类型和引用类型在内存中的存储方式（画图说明） 值类型按值存储 引用类型按引用存储 值类型复制和引用类型复制（画图说明） 值类型按值复制 引用类型按引用复制 值类型和引用类型参数传递（画图说明） 值类型按值传递 引用类型按引用传递 值类型与引用类型的差别 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，复制的是值的副本 引用类型的值是对象，保存在堆内存 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象 小结 类型检测方式 值类型和引用类型的存储方式 值类型复制和引用类型复制 方法参数中 值类型数据传递 和 引用类型数据传递 JavaScript 执行过程JavaScript 运行分为两个阶段： 预解析 全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高） 函数内部预解析（所有的变量、函数和形参都会参与预解析） 函数 形参 普通变量 执行 先预解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。 JavaScript 面向对象编程 面向对象介绍什么是对象 Everything is object （万物皆对象） 对象到底是什么，我们可以从两次层次来理解。 (1) 对象是单个事物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 (2) 对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。 ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。 什么是面向对象 面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 面向对象与面向过程： 面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊 面向对象就是找一个对象，指挥得结果 面向对象将执行者转变成指挥者 面向对象不是面向过程的替代，而是面向过程的封装 面向对象的特性： 封装性 继承性 [多态性] 扩展阅读： 维基百科 - 面向对象程序设计 知乎：如何用一句话说明什么是面向对象思想？ 知乎：什么是面向对象编程思想？ 程序中面向对象的基本体现在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（ Class ）的概念。 我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示： 12var std1 = &#123; name: 'Michael', score: 98 &#125;var std2 = &#123; name: 'Bob', score: 81 &#125; 而处理学生成绩可以通过函数实现，比如打印学生的成绩： 123function printScore (student) &#123; console.log('姓名：' + student.name + ' ' + '成绩：' + student.score)&#125; 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是 Student 这种数据类型应该被视为一个对象，这个对象拥有 name 和 score 这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 printScore 消息，让对象自己把自己的数据打印出来。 抽象数据行为模板（Class）： 12345678function Student (name, score) &#123; this.name = name this.score = score&#125;Student.prototype.printScore = function () &#123; console.log('姓名：' + this.name + ' ' + '成绩：' + this.score)&#125; 根据模板创建具体实例对象（Instance）： 12var std1 = new Student('Michael', 98)var std2 = new Student('Bob', 81) 实例对象具有自己的具体行为（给对象发消息）： 12std1.printScore() // =&gt; 姓名：Michael 成绩：98std2.printScore() // =&gt; 姓名：Bob 成绩 81 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。 所以，面向对象的设计思想是： 抽象出 Class 根据 Class 创建 Instance 指挥 Instance 得结果 面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。 创建对象简单方式我们可以直接通过 new Object() 创建： 1234567var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建： 1234567var person = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 对于上面的写法固然没有问题，但是假如我们要生成两个 person 实例对象呢？ 123456789101112131415var person1 = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125;var person2 = &#123; name: 'Mike', age: 16, sayName: function () &#123; console.log(this.name) &#125;&#125; 通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。 简单方式的改进：工厂函数我们可以写一个函数，解决代码重复问题： 123456789function createPerson (name, age) &#123; return &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125;&#125; 然后生成实例对象： 12var p1 = createPerson('Jack', 18)var p2 = createPerson('Mike', 18) 这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数内容引导： 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 普通函数调用和构造函数调用的区别 构造函数的返回值 构造函数的静态成员和实例成员 函数也是对象 实例成员 静态成员 构造函数的问题 更优雅的工厂函数：构造函数一种更优雅的工厂函数就是下面这样，构造函数： 12345678910111213function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person('Jack', 18)p1.sayName() // =&gt; Jackvar p2 = new Person('Mike', 23)p2.sayName() // =&gt; Mike 解析构造函数代码的执行在上面的示例中，Person() 函数取代了 createPerson() 函数，但是实现效果是一样的。这是为什么呢？ 我们注意到，Person() 中的代码与 createPerson() 有以下几点不同之处： 没有显示的创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 函数名使用的是大写的 Person 而要创建 Person 实例，则必须使用 new 操作符。以这种方式调用构造函数会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码 返回新对象 下面是具体的伪代码： 12345678910111213141516function Person (name, age) &#123; // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象 // var instance = &#123;&#125; // 然后让内部的 this 指向 instance 对象 // this = instance // 接下来所有针对 this 的操作实际上操作的就是 instance this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125; // 在函数的结尾处会将 this 返回，也就是 instance // return this&#125; 构造函数和实例对象的关系使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。在每一个实例对象中的__proto__中同时有一个 constructor 属性，该属性指向创建该实例的构造函数： 123console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true 对象的 constructor 属性最初是用来标识对象类型的，但是，如果要检测对象的类型，还是使用 instanceof 操作符更可靠一些： 12console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true 总结： 构造函数是根据具体的事物抽象出来的抽象模板 实例对象是根据抽象的构造函数模板得到的具体实例对象 每一个实例对象都具有一个 constructor 属性，指向创建该实例的构造函数 注意： constructor 是实例的属性的说法不严谨，具体后面的原型会讲到 可以通过实例的 constructor 属性判断实例和构造函数之间的关系 注意：这种方式不严谨，推荐使用 instanceof 操作符，后面学原型会解释为什么 构造函数的问题使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： 1234567891011function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = function () &#123; console.log('hello ' + this.name) &#125;&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16) 在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 1console.log(p1.sayHello === p2.sayHello) // =&gt; false 对于这种问题我们可以把需要共享的函数定义到构造函数外部： 123456789101112131415function sayHello = function () &#123; console.log('hello ' + this.name)&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = sayHello&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; true 这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。 你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题： 12345678910111213141516171819202122var fns = &#123; sayHello: function () &#123; console.log('hello ' + this.name) &#125;, sayAge: function () &#123; console.log(this.age) &#125;&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = fns.sayHello this.sayAge = fns.sayAge&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; trueconsole.log(p1.sayAge === p2.sayAge) // =&gt; true 至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。但是代码看起来还是那么的格格不入，那有没有更好的方式呢？ 小结 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 构造函数的问题 原型内容引导： 使用 prototype 原型对象解决构造函数的问题 分析 构造函数、prototype 原型对象、实例对象 三者之间的关系 属性成员搜索原则：原型链 实例对象读写原型对象中的成员 原型对象的简写形式 原生对象的原型 Object Array String … 原型对象的问题 构造的函数和原型对象使用建议 更好的解决方案： prototypeJavascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 1234567891011121314151617function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.type = 'human'Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // =&gt; true 这时所有实例的 type 属性和 sayName() 方法，其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 构造函数、实例、原型三者之间的关系 任何函数都具有一个 prototype 属性，该属性是一个对象。 123456function F () &#123;&#125;console.log(F.prototype) // =&gt; objectF.prototype.sayHi = function () &#123; console.log('hi!')&#125; 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数。 1console.log(F.constructor === F) // =&gt; true 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。 12var instance = new F()console.log(instance.__proto__ === F.prototype) // =&gt; true __proto__ 是非标准属性。 实例对象可以直接访问原型对象成员。 1instance.sayHi() // =&gt; hi! 总结： 任何函数都具有一个 prototype 属性，该属性是一个对象 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__ 所有实例都直接或间接继承了原型对象的成员 属性成员的搜索原则：原型链了解了 构造函数-实例-原型对象 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性 搜索首先从对象实例本身开始 如果在实例中找到了具有给定名字的属性，则返回该属性的值 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性 如果在原型对象中找到了这个属性，则返回该属性的值 也就是说，在我们调用 person1.sayName() 的时候，会先后执行两次搜索： 首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。 ”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。 ”于是，它就读取那个保存在原型对象中的函数。 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。 而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 总结： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 实例对象读写原型对象成员读取： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 值类型成员写入（实例对象.值类型成员 = xx）： 当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上 也就是说该行为实际上会屏蔽掉对原型对象成员的访问 引用类型成员写入（实例对象.引用类型成员 = xx）： 同上 复杂类型修改（实例对象.成员.xx = xx）： 同样会先在自己身上找该成员，如果自己身上找到则直接修改 如果自己身上找不到，则沿着原型链继续查找，如果找到则修改 如果一直到原型链的末端还没有找到该成员，则报错（实例对象.undefined.xx = xx） 更简单的原型语法我们注意到，前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： 1234567891011function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 在该示例中，我们将 Person.prototype 重置到了一个新的对象。这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： 123456789101112function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; constructor: Person, // =&gt; 手动将 constructor 指向正确的构造函数 type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 原生对象的原型 所有函数都有 prototype 属性对象。 Object.prototype Function.prototype Array.prototype String.prototype Number.prototype Date.prototype … 练习：为数组对象和字符串对象扩展原型方法。 原型对象的问题 共享数组 共享对象 如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则就是问题。 一个更好的建议是，最好不要让实例之间互相共享这些数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。 原型对象使用建议 私有成员（一般就是非函数成员）放到构造函数中 共享成员（一般就是函数）放到原型对象中 如果重置了 prototype 记得修正 constructor 的指向 案例：随机方块 面向对象游戏案例：贪吃蛇案例相关源码以上传到 GitHub ：https://github.com/lipengzhou/new-snake 案例介绍游戏演示在线演示地址：贪吃蛇 案例目标游戏的目的是用来体会js高级语法的使用 不需要具备抽象对象的能力，使用面向对象的方式分析问题，需要一个漫长的过程。 功能实现搭建页面放一个容器盛放游戏场景 div#map，设置样式 123456#map &#123; width: 800px; height: 600px; background-color: #ccc; position: relative;&#125; 分析对象 游戏对象 蛇对象 食物对象 创建食物对象 Food 属性 x y width height color 方法 render 随机创建一个食物对象，并输出到map上 创建Food的构造函数，并设置属性 1234567891011var position = 'absolute';var elements = [];function Food(x, y, width, height, color) &#123; this.x = x || 0; this.y = y || 0; // 食物的宽度和高度(像素) this.width = width || 20; this.height = height || 20; // 食物的颜色 this.color = color || 'green';&#125; 通过原型设置render方法，实现随机产生食物对象，并渲染到map上 12345678910111213141516Food.prototype.render = function (map) &#123; // 随机食物的位置，map.宽度/food.宽度，总共有多少分food的宽度，随机一下。然后再乘以food的宽度 this.x = parseInt(Math.random() * map.offsetWidth / this.width) * this.width; this.y = parseInt(Math.random() * map.offsetHeight / this.height) * this.height; // 动态创建食物对应的div var div = document.createElement('div'); map.appendChild(div); div.style.position = position; div.style.left = this.x + 'px'; div.style.top = this.y + 'px'; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; div.style.backgroundColor = this.color; elements.push(div);&#125; 通过自调用函数，进行封装，通过window暴露Food对象 1window.Food = Food; 创建蛇对象 Snake 属性 width 蛇节的宽度 默认20 height 蛇节的高度 默认20 body 数组，蛇的头部和身体，第一个位置是蛇头 direction 蛇运动的方向 默认right 可以是 left top bottom 方法 render 把蛇渲染到map上 Snake构造函数 1234567891011121314var position = 'absolute';var elements = [];function Snake(width, height, direction) &#123; // 设置每一个蛇节的宽度 this.width = width || 20; this.height = height || 20; // 蛇的每一部分, 第一部分是蛇头 this.body = [ &#123;x: 3, y: 2, color: 'red'&#125;, &#123;x: 2, y: 2, color: 'red'&#125;, &#123;x: 1, y: 2, color: 'red'&#125; ]; this.direction = direction || 'right';&#125; render方法 12345678910111213Snake.prototype.render = function(map) &#123; for(var i = 0; i &lt; this.body.length; i++) &#123; var obj = this.body[i]; var div = document.createElement('div'); map.appendChild(div); div.style.left = obj.x * this.width + 'px'; div.style.top = obj.y * this.height + 'px'; div.style.position = position; div.style.backgroundColor = obj.color; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; &#125;&#125; 在自调用函数中暴露Snake对象 1window.Snake = Snake; 创建游戏对象游戏对象，用来管理游戏中的所有对象和开始游戏 Game 属性 food snake map 方法 start 开始游戏（绘制所有游戏对象） 构造函数 12345function Game(map) &#123; this.food = new Food(); this.snake = new Snake(); this.map = map;&#125; 开始游戏，渲染食物对象和蛇对象 1234Game.prototype.start = function () &#123; this.food.render(this.map); this.snake.render(this.map);&#125; 游戏的逻辑写蛇的move方法 在蛇对象(snake.js)中，在Snake的原型上新增move方法 让蛇移动起来，把蛇身体的每一部分往前移动一下 蛇头部分根据不同的方向决定 往哪里移动 1234567891011121314151617181920212223Snake.prototype.move = function (food, map) &#123; // 让蛇身体的每一部分往前移动一下 var i = this.body.length - 1; for(; i &gt; 0; i--) &#123; this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; &#125; // 根据移动的方向，决定蛇头如何处理 switch(this.direction) &#123; case 'left': this.body[0].x -= 1; break; case 'right': this.body[0].x += 1; break; case 'top': this.body[0].y -= 1; break; case 'bottom': this.body[0].y += 1; break; &#125;&#125; 在game中测试 12this.snake.move(this.food, this.map);this.snake.render(this.map); 让蛇自己动起来 私有方法 1234什么是私有方法？ 不能被外部访问的方法如何创建私有方法？ 使用自调用函数包裹 在game.js中 添加runSnake的私有方法，开启定时器调用蛇的move和render方法，让蛇动起来 判断蛇是否撞墙 1234567891011121314151617181920212223function runSnake() &#123; var timerId = setInterval(function() &#123; this.snake.move(this.food, this.map); // 在渲染前，删除之前的蛇 this.snake.render(this.map); // 判断蛇是否撞墙 var maxX = this.map.offsetWidth / this.snake.width; var maxY = this.map.offsetHeight / this.snake.height; var headX = this.snake.body[0].x; var headY = this.snake.body[0].y; if (headX &lt; 0 || headX &gt;= maxX) &#123; clearInterval(timerId); alert('Game Over'); &#125; if (headY &lt; 0 || headY &gt;= maxY) &#123; clearInterval(timerId); alert('Game Over'); &#125; &#125;.bind(that), 150);&#125; 在snake中添加删除蛇的私有方法，在render中调用 12345678910function remove() &#123; // 删除渲染的蛇 var i = elements.length - 1; for(; i &gt;= 0; i--) &#123; // 删除页面上渲染的蛇 elements[i].parentNode.removeChild(elements[i]); // 删除elements数组中的元素 elements.splice(i, 1); &#125;&#125; 在game中通过键盘控制蛇的移动方向 12345678910111213141516171819202122function bindKey() &#123; document.addEventListener('keydown', function(e) &#123; switch (e.keyCode) &#123; case 37: // left this.snake.direction = 'left'; break; case 38: // top this.snake.direction = 'top'; break; case 39: // right this.snake.direction = 'right'; break; case 40: // bottom this.snake.direction = 'bottom'; break; &#125; &#125;.bind(that), false);&#125; 在start方法中调用 1bindKey(); 判断蛇是否吃到食物123456789101112131415161718// 在Snake的move方法中// 在移动的过程中判断蛇是否吃到食物// 如果蛇头和食物的位置重合代表吃到食物// 食物的坐标是像素，蛇的坐标是几个宽度，进行转换var headX = this.body[0].x * this.width;var headY = this.body[0].y * this.height;if (headX === food.x &amp;&amp; headY === food.y) &#123; // 吃到食物，往蛇节的最后加一节 var last = this.body[this.body.length - 1]; this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;) // 把现在的食物对象删除，并重新随机渲染一个食物对象 food.render(map);&#125; 其它处理把html中的js代码放到index.js中避免html中出现js代码 自调用函数的参数1234(function (window, undefined) &#123; var document = window.document;&#125;(window, undefined)) 传入window对象 将来代码压缩的时候，可以吧 function (window) 压缩成 function (w) 传入undefined 在将来会看到别人写的代码中会把undefined作为函数的参数(当前案例没有使用)因为在有的老版本的浏览器中 undefined可以被重新赋值，防止undefined 被重新赋值 整理代码现在的代码结构清晰，谁出问题就找到对应的js文件即可。通过自调用函数，已经防止了变量命名污染的问题 但是，由于js文件数较多，需要在页面上引用，会产生文件依赖的问题(先引入那个js，再引入哪个js)将来通过工具把js文件合并并压缩。现在手工合并js文件演示 问题1 1234567891011121314// 如果存在多个自调用函数要用分号分割，否则语法错误// 下面代码会报错(function () &#123;&#125;())(function () &#123;&#125;())// 所以代码规范中会建议在自调用函数之前加上分号// 下面代码没有问题;(function () &#123;&#125;());(function () &#123;&#125;()) 问题2 123456789// 当自调用函数 前面有函数声明时，会把自调用函数作为参数// 所以建议自调用函数前，加上;var a = function () &#123; alert('11');&#125; (function () &#123; alert('22');&#125;()) 继承什么是继承 现实生活中的继承 程序中的继承 构造函数的属性继承：借用构造函数12345678910111213function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;function Student (name, age) &#123; // 借用构造函数继承属性成员 Person.call(this, name, age)&#125;var s1 = Student('张三', 18)console.log(s1.type, s1.name, s1.age) // =&gt; human 张三 18 构造函数的原型方法继承：拷贝继承（for-in）12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 原型对象拷贝继承原型对象成员for(var key in Person.prototype) &#123; Student.prototype[key] = Person.prototype[key]&#125;var s1 = Student('张三', 18)s1.sayName() // =&gt; hello 张三 另一种继承方式：原型继承12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 利用原型的特性实现继承Student.prototype = new Person()var s1 = Student('张三', 18)console.log(s1.type) // =&gt; humans1.sayName() // =&gt; hello 张三 函数进阶函数的定义方式 函数声明 函数表达式 new Function 函数声明123function foo () &#123;&#125; 函数表达式123var foo = function () &#123;&#125; 函数声明与函数表达式的区别 函数声明必须有名字 函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用 函数表达式类似于变量赋值 函数表达式可以没有名字，例如匿名函数 函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用 下面是一个根据条件定义函数的例子： 123456789if (true) &#123; function f () &#123; console.log(1) &#125;&#125; else &#123; function f () &#123; console.log(2) &#125;&#125; 以上代码执行结果在不同浏览器中结果不一致。 不过我们可以使用函数表达式解决上面的问题： 1234567891011var fif (true) &#123; f = function () &#123; console.log(1) &#125;&#125; else &#123; f = function () &#123; console.log(2) &#125;&#125; 函数的调用方式 普通函数 构造函数 对象方法 函数内 this 指向的不同场景函数的调用方式决定了 this 指向的不同： 调用方式 非严格模式 备注 普通函数调用 window 严格模式下是 undefined 构造函数调用 实例对象 原型方法中 this 也是实例对象 对象方法调用 该方法所属对象 紧挨着的对象 事件绑定方法 绑定事件对象 定时器函数 window 这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。 函数也是对象 所有函数都是 Function 的实例 call、apply、bind那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。这就是接下来我们要学习的 call、apply、bind 三个函数方法。 callcall() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 在 fun 函数运行时指定的 this 值 如果指定了 null 或者 undefined 则内部 this 指向 window arg1, arg2, ... 指定的参数列表 applyapply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：该方法的作用和 call() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.apply(thisArg, [argsArray]) 参数： thisArg argsArray apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数列表。例如： 1fun.apply(this, ['eat', 'bananas']) bindbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值： 返回由指定的this值和初始化参数改造的原函数拷贝。 示例1： 123456789101112131415this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 示例2： 12345678910111213141516function LateBloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// Declare bloom after a delay of 1 secondLateBloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 1000);&#125;;LateBloomer.prototype.declare = function() &#123; console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');&#125;;var flower = new LateBloomer();flower.bloom(); // 一秒钟后, 调用'declare'方法 小结 call 和 apply 特性一样 都是用来调用函数，而且是立即调用 但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向 call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可 apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递 如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window bind 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数 它和 call、apply 最大的区别是：bind 不会调用 bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递 在 bind 的同时，以参数列表的形式进行传递 在调用的时候，以参数列表的形式进行传递 那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部 函数的其它成员 arguments 实参集合 caller 函数的调用者 length 形参的个数 name 函数的名称 12345678910111213function fn(x, y, z) &#123; console.log(fn.length) // =&gt; 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // =&gt; 函数的名字&#125;function f() &#123; fn(10, 20, 30)&#125;f() 高阶函数 函数可以作为参数 函数可以作为返回值 作为参数12345678910function eat (callback) &#123; setTimeout(function () &#123; console.log('吃完了') callback() &#125;, 1000)&#125;eat(function () &#123; console.log('去唱歌')&#125;) 作为返回值1234567891011function genFun (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === type &#125;&#125;var isArray = genFun('[object Array]')var isObject = genFun('[object Object]')console.log(isArray([])) // =&gt; trueconsole.log(isArray(&#123;&#125;)) // =&gt; true 函数闭包1234567891011121314151617function fn () &#123; var count = 0 return &#123; getCount: function () &#123; console.log(count) &#125;, setCount: function () &#123; count++ &#125; &#125;&#125;var fns = fn()fns.getCount() // =&gt; 0fns.setCount()fns.getCount() // =&gt; 1 作用域、作用域链、预解析 全局作用域 函数作用域 没有块级作用域 12345678910&#123; var foo = 'bar'&#125;console.log(foo)if (true) &#123; var a = 123&#125;console.log(a) 作用域链示例代码： 123456789101112131415161718var a = 10function fn () &#123; var b = 20 function fn1 () &#123; var c = 30 console.log(a + b + c) &#125; function fn2 () &#123; var d = 40 console.log(c + d) &#125; fn1() fn2()&#125; 内层作用域可以访问外层作用域，反之不行 什么是闭包闭包就是能够读取其他函数内部变量的函数，由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 可以在函数外部读取函数内部成员 让函数内成员始终存活在内存中 一些关于闭包的例子示例1： 123456var arr = [10, 20, 30]for(var i = 0; i &lt; arr.length; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;&#125; 示例2： 12345678console.log(111)for(var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 0)&#125;console.log(222) 示例3：投票 示例4：判断类型 示例5：沙箱模式 闭包的思考题思考题 1： 1234567891011var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 思考题 2： 1234567891011var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function () &#123; var that = this; return function () &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 小结函数递归递归执行模型123456789101112131415161718192021222324function fn1 () &#123; console.log(111) fn2() console.log('fn1')&#125;function fn2 () &#123; console.log(222) fn3() console.log('fn2')&#125;function fn3 () &#123; console.log(333) fn4() console.log('fn3')&#125;function fn4 () &#123; console.log(444) console.log('fn4')&#125;fn1() 举个栗子：计算阶乘的递归函数1234567function factorial (num) &#123; if (num &lt;= 1) &#123; return 1 &#125; else &#123; return num * factorial(num - 1) &#125;&#125; 递归应用场景 深拷贝 菜单树 遍历 DOM 树 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ 验证邮编： 1^\d&#123;6&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn： 1^\w+@\w+\.\w+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;\(.\d&#123;1,3&#125;)&#123;3&#125;$ JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\d', 'i');var reg = new Regex('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); ###匹配正则表达式// console.log(/./.test(“除了回车换行以为的任意字符”));//true// console.log(/.*/.test(“0个到多个”));//true// console.log(/.+/.test(“1个到多个”));//true// console.log(/.?/.test(“哈哈”));//true// console.log(/[0-9]/.test(“9527”));//true// console.log(/[a-z]/.test(“what”));//true// console.log(/[A-Z]/.test(“Are”));//true// console.log(/[a-zA-Z]/.test(“干啥子”));//false// console.log(/[0-9a-zA-Z]/.test(“9ebg”));//true// console.log(/b|(ara)/.test(“abra”));//true// console.log(/[a-z]{2,3}/.test(“arfsf”));//true console.log(/\d/.test(&quot;998&quot;));//true console.log(/\d*/.test(&quot;998&quot;));//true console.log(/\d+/.test(&quot;998&quot;));//true console.log(/\d{0,}/.test(&quot;998&quot;));//true console.log(/\d{2,3}/.test(&quot;998&quot;));//true console.log(/\D/.test(&quot;eat&quot;));//true console.log(/\s/.test(&quot; &quot;));//true console.log(/\S/.test(&quot;嘎嘎&quot;));//true console.log(/\w/.test(&quot;_&quot;));//true console.log(/\W/.test(&quot;_&quot;));//true ###正则表达式案例1.验证密码强弱2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}3.验证中文名字[\u4e00-\u9fa5] 正则提取123456789101112131415161718192021222324252627// 1. 提取工资var str = "张三：1000，李四：5000，王五：8000。";var array = str.match(/\d+/g);console.log(array);// 2. 提取email地址var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;var str = "123123@xx.com";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125; 正则替换123456789// 1. 替换所有空白var str = " 123AD asadf asadfasf adf ";str = str.replace(/\s/g,"xx");console.log(str);// 2. 替换所有,|，var str = "abc,efg,123，abc,123，a";str = str.replace(/,|，/g, ".");console.log(str); 案例：表单验证12345QQ号：&lt;input type="text" id="txtQQ"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type="text" id="txtEMail"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type="text" id="txtPhone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type="text" id="txtBirthday"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type="text" id="txtName"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById("txtQQ");var txtEMail = document.getElementById("txtEMail");var txtPhone = document.getElementById("txtPhone");var txtBirthday = document.getElementById("txtBirthday");var txtName = document.getElementById("txtName");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的QQ号"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\w+@\w+\.\w+(\.\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的EMail地址"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, "请输入正确的出生日期");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id="frm"&gt; QQ号：&lt;input type="text" name="txtQQ" data-rule="qq"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type="text" name="txtEMail" data-rule="email"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type="text" name="txtPhone" data-rule="phone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type="text" name="txtBirthday" data-rule="date"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type="text" name="txtName" data-rule="cn"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\d&#123;5,12&#125;$/, tip: "请输入正确的QQ" &#125;, &#123; name: 'email', reg: /^\w+@\w+\.\w+(\.\w+)?$/, tip: "请输入正确的邮箱地址" &#125;, &#123; name: 'phone', reg: /^\d&#123;11&#125;$/, tip: "请输入正确的手机号码" &#125;, &#123; name: 'date', reg: /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/, tip: "请输入正确的出生日期" &#125;, &#123; name: 'cn', reg: /^[\u4e00-\u9fa5]&#123;2,4&#125;$/, tip: "请输入正确的姓名" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125; 补充伪数组和数组在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。 对象与数组的关系在说区别之前，需要先提到另外一个知识，就是 JavaScript 的原型继承。所有 JavaScript 的内置构造函数都是继承自 Object.prototype 。在这个前提下，可以理解为使用 new Array() 或 [] 创建出来的数组对象，都会拥有 Object.prototype 的属性值。 1234var obj = &#123;&#125;;// 拥有 Object.prototype 的属性值var arr = [];//使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，//那么，它将同时拥有 Array.prototype 和 Object.prototype 的属性值 可以得到对象和数组的第一个区别：对象没有数组 Array.prototype 的属性值。 什么是数组数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码： 12345678910var obj = &#123;&#125;;var arr = []; obj[2] = 'a';arr[2] = 'a'; console.log(obj[2]); // =&gt; aconsole.log(arr[2]); // =&gt; aconsole.log(obj.length); // =&gt; undefinedconsole.log(arr.length); // =&gt; 3 obj[2]输出’a’，是因为对象就是普通的键值对存取数据 而arr[2]输出’a’ 则不同，数组是通过索引来存取数据，arr[2]之所以输出’a’，是因为数组arr索引2的位置已经存储了数据 obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined 而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值 为什么arr.length输出3，而不是1 在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数 什么是伪数组 拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法 伪数组，就是像数组一样有 length 属性，也有 0、1、2、3 等属性的对象，看起来就像数组一样，但不是数组，比如: 123456789101112var fakeArray = &#123; "0": "first", "1": "second", "2": "third", length: 3&#125;; for (var i = 0; i &lt; fakeArray.length; i++) &#123; console.log(fakeArray[i]);&#125; Array.prototype.join.call(fakeArray,'+'); 常见的伪数组有： 函数内部的 arguments DOM 对象列表（比如通过 document.getElementsByTags 得到的列表） jQuery 对象（比如 $(&quot;div&quot;) ） 伪数组是一个 Object，而真实的数组是一个 Array。 伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多方法，比如： 123456789101112var arr = Array.prototype.slice.call(arguments); Array.prototype.forEach.call(arguments, function(v) &#123; // 循环arguments对象&#125;);// push// some// every// filter// map// ... 以上在借用数组的原型方法的时候都可以通过数组直接量来简化使用： 1234567891011121314var obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;;[].push.call(obj, 'd')console.log([].slice.call(obj));[].forEach.call(obj, function (num, index) &#123; console.log(num)&#125;) 小结 对象没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array 数组是基于索引的实现， length 会自动更新，而对象是键值对 使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法 JavaScript 垃圾回收机制JavaScript 运行机制：Event LoopObject静态成员 Object.assign() Object.create() Object.keys() Object.defineProperty() 实例成员 constructor hasOwnProperty() isPrototypeOf propertyIsEnumerable() toString() valueOf() 附录A 代码规范代码风格 JavaScript Standard Style Airbnb JavaScript Style Guide() { 校验工具 JSLint JSHint ESLint B Chrome 开发者工具C 文档相关工具 电子文档制作工具: docute 流程图工具：DiagramDesigner]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery详解1]]></title>
    <url>%2F2018%2F12%2F12%2FjQuery%E8%AF%A6%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[jQuery基本概念 学习目标：学会如何使用jQuery，掌握jQuery的常用api，能够使用jQuery实现常见的效果。 为什么要学习jQuery？【01-让div显示与设置内容.html】 使用javascript开发过程中，有许多的缺点： 123451. 查找元素的方法太少，麻烦。2. 遍历伪数组很麻烦，通常要嵌套一大堆的for循环。3. 有兼容性问题。4. 想要实现简单的动画效果，也很麻烦5. 代码冗余。 jQuery初体验【02-让div显示与设置内容.html】 12345678910$(document).ready(function () &#123; $("#btn1").click(function () &#123; //隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。 $("div").show(200); &#125;); $("#btn2").click(function () &#123; $("div").text("我是内容"); &#125;);&#125;); 优点总结： 123451. 查找元素的方法多种多样，非常灵活2. 拥有隐式迭代特性，因此不再需要手写for循环了。3. 完全没有兼容性问题。4. 实现动画非常简单，而且功能更加的强大。5. 代码简单、粗暴。 没有对比，就没有伤害，有了对比，处处戳中要害。 什么是jQuery? jQuery的官网 http://jquery.com/jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。 js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js） 我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。 jQuery的版本 官网下载地址：http://jquery.com/download/jQuery版本有很多，分为1.x 2.x 3.x 大版本分类： 123451.x版本：能够兼容IE678浏览器2.x版本：不兼容IE678浏览器1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。3.x版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678） 关于压缩版和未压缩版 12jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。 jQuery的入口函数使用jQuery的三个步骤： 1231. 引入jQuery文件2. 入口函数3. 功能实现 关于jQuery的入口函数： 12345678//第一种写法$(document).ready(function() &#123; &#125;);//第二种写法$(function() &#123; &#125;); jQuery入口函数与js入口函数的对比 121. JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。2. jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。 jQuery对象与DOM对象的区别（重点）12341. DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。2. jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。3. jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））4. DOM对象与jQuery对象的方法不能混用。 DOM对象转换成jQuery对象：【联想记忆：花钱】 12var $obj = $(domObj);// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象 jQuery对象转换成DOM对象： 12345var $li = $(“li”);//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0) 【练习：隔行变色案例.html】 选择器什么是jQuery选择器jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】 jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。 基本选择器 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 跟CSS的选择器一模一样。 过滤选择器 这类选择器都带冒号: 名称 用法 描述 :eq（index） $(“li:eq(2)”).css(“color”, ”red”); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(“li:odd”).css(“color”, ”red”); 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”).css(“color”, ”red”); 获取到的li元素中，选择索引号为偶数的元素 【案例：隔行变色】 筛选选择器(方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 名称 用法 描述 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，子类选择器 find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 parent() $(“#first”).parent(); 查找父亲 eq(index) $(“li”).eq(2); 相当于$(“li:eq(2)”),index从0开始 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 1234【案例：下拉菜单】this+children+mouseenter+mouseleave【案例：突出展示】siblings+find【案例：手风琴】next+parent【案例：淘宝精品】index+eq jQuery特殊属性操作val方法 val方法用于设置和获取表单元素的值，例如input、textarea的值 1234//设置值$("#name").val(“张三”);//获取值$("#name").val(); 【案例：京东搜索.html】 html方法与text方法 html方法相当于innerHTML text方法相当于innerText 123456789//设置内容$(“div”).html(“&lt;span&gt;这是一段内容&lt;/span&gt;”);//获取内容$(“div”).html()//设置内容$(“div”).text(“&lt;span&gt;这是一段内容&lt;/span&gt;”);//获取内容$(“div”).text() 区别：html方法会识别html标签，text方法会那内容直接当成字符串，并不会识别html标签。 width方法与height方法 设置或者获取高度 1234//带参数表示设置高度$(“img”).height(200);//不带参数获取高度$(“img”).height(); 获取网页的可视区宽高 1234//获取可视区宽度$(window).width();//获取可视区高度$(window).height(); scrollTop与scrollLeft 设置或者获取垂直滚动条的位置 1234//获取页面被卷曲的高度$(window).scrollTop();//获取页面被卷曲的宽度$(window).scrollLeft(); 【案例：仿腾讯固定菜单栏案例】【案例：小火箭返航案例】 offset方法与position方法 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。 1234//获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();//获取相对于其最近的有定位的父元素的位置。$(selector).position(); jQuery事件机制 JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。 jQuery事件发展历程(了解)简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐) 简单事件注册 123click(handler) 单击事件mouseenter(handler) 鼠标进入事件mouseleave(handler) 鼠标离开事件 缺点：不能同时注册多个事件 bind方式注册事件 12345//第一个参数：事件类型//第二个参数：事件处理程序$("p").bind("click mouseenter", function()&#123; //事件响应方法&#125;); 缺点：不支持动态事件绑定 delegate注册委托事件 123456// 第一个参数：selector，要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$(".parentBox").delegate("p", "click", function()&#123; //为 .parentBox下面的所有的p标签绑定事件&#125;); 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on注册事件 on注册事件(重点) jQuery1.7之后，jQuery用on统一了所有事件的处理方法。 最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。 on注册简单事件 12// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on( "click", function() &#123;&#125;); on注册委托事件 12// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on( "click",“span”, function() &#123;&#125;); on注册事件的语法： 12345// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events[,selector][,data],handler); 事件解绑 unbind方式（不用） 12$(selector).unbind(); //解绑所有的事件$(selector).unbind("click"); //解绑指定的事件 undelegate方式（不用） 12$( selector ).undelegate(); //解绑所有的delegate事件$( selector).undelegate( “click” ); //解绑所有的click事件 off方式（推荐） 1234// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件$(selector).off("click"); 触发事件12$(selector).click(); //触发 click事件$(selector).trigger("click"); jQuery事件对象jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。 12345678910//screenX和screenY 对应屏幕最左上角的值//clientX和clientY 距离页面左上角的位置（忽视滚动条）//pageX和pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）//event.keyCode 按下的键盘代码//event.data 存储绑定事件时传递的附加数据//event.stopPropagation() 阻止事件冒泡行为//event.preventDefault() 阻止浏览器默认行为//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。 【案例：钢琴版导航（加强）.html】 jQuery补充知识点链式编程 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。 1end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。 【案例：五角星评分案例.html】 each方法 jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。 作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数 123// 参数一表示当前元素在所有匹配元素中的索引号// 参数二表示当前元素（DOM对象）$(selector).each(function(index,element)&#123;&#125;); 【案例：不同的透明度.html】 多库共存 jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权. 1var c = $.noConflict();//释放$的控制权,并且把$的能力给了c 插件常用插件 插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。 jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。 jquery.color.js animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。 使用插件的步骤 1231. 引入jQuery文件2. 引入插件（如果有用到css的话，需要引入css）3. 使用插件 jquery.lazyload.js懒加载插件 jquery.ui.js插件jQueryUI专指由jQuery官方维护的UI方向的插件。 官方API：http://api.jqueryui.com/category/all/ 其他教程：jQueryUI教程 基本使用: 12342. 1. 引入jQueryUI的样式文件2. 引入jQuery3. 引入jQueryUI的js文件4. 使用jQueryUI功能 使用jquery.ui.js实现新闻模块的案例 制作jquery插件 原理：jquery插件其实说白了就是给jquery对象增加一个新的方法，让jquery对象拥有某一个功能。 12//通过给$.fn添加方法就能够扩展jquery对象$.fn. pluginName = function() &#123;&#125;; 制作手风琴插件]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是AJAX（前后端分离和不分离的优势弊端）]]></title>
    <url>%2F2018%2F12%2F12%2F%E4%BB%80%E4%B9%88%E6%98%AFAJAX%EF%BC%9F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%92%8C%E4%B8%8D%E5%88%86%E7%A6%BB%E7%9A%84%E4%BC%98%E5%8A%BF%E5%BC%8A%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[AJAX基础知识及核心原理解读AJAX基础知识 什么是AJAX？ async javascript and xml 异步的JS和XML XML：可扩展的标记语言 作用：是用来存储数据的（通过自己扩展的标记名称清晰地展示出数据结构） ajax之所以称为异步的js和xml，主要原因是：以前最开始使用ajax实现客户端和服务端数据通信的时候，传输数据的格式一般都是xml格式的数据，我们把他称之为异步的js和xml（现在一般都是基于JSON格式来进行数据传输的） 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;root&gt; &lt;student&gt; &lt;name&gt;海洋&lt;/name&gt; &lt;age&gt;10&lt;/age&gt; &lt;score&gt; &lt;deutsch&gt;100&lt;/deutsch&gt; &lt;IT&gt;100&lt;/IT&gt; &lt;english&gt;100&lt;/english&gt; &lt;/score&gt; &lt;/student&gt;&lt;/root&gt; 异步的JS 这里的异步不是说ajax只能基于异步进行请求（虽然建议都是使用异步编程），这里的异步特指的是 局部刷新 局部刷新 VS 全局刷新 全局刷新： 在非完全前后端分离的项目中，前端开发只需要完成页面的制作，并且把一些基础的人机交互效果使用js完成即可，页面中需要动态呈现内容的部分，都是交给后台开发工程师做数据绑定和基于服务器进行渲染的（服务器端渲染） 【优势】 动态展示的数据在页面的源代码中可以看见，有利于SEO优化推广（有利于搜索引擎的收录和抓取） 从服务器端获取的结果已经是解析渲染完成的了，不需要客户端再去解析渲染了，所以页面加载速度快（前提是服务器端处理的速度够快，能够处理过来），所以类似于京东，淘宝这些网站，首屏数据一般都是由服务器端渲染的 【弊端】 如果页面中存在实时更新的数据，每一次想要展示最新的数据，页面都要重新刷新一次，这样肯定不行，非常耗性能 都交给服务器端做数据渲染，服务器端的压力太大，如果服务器处理不过来，页面呈现的速度更慢（所以像京东和淘宝这类的网站，除了首屏是服务器端渲染的，其他屏一般都是客户端做数据渲染绑定的） 这种模式不利于开发，（开发效率低） 局部刷新 目前市场上大部分项目都是前后端完全分离的项目（也有非完全前后端分离的占少数） 前后端完全分离的项目，页面中需要动态绑定的数据是交给客户端完成渲染的 向服务器端发送AJAX请求 把从服务器端获取的数据解析处理，拼接成我们需要展示的HTML字符串 把拼接好的字符串替换页面中的某一部分内容（局部刷新），页面不需要整体重新加载，局部渲染即可 【优势】 我们可以根据需求，任意修改页面中的某一部分内容（例如实时刷新），整体页面不刷新，性能好，体验好（所有表单验证，需要实时刷新的等需求都要基于AJAX实现） 有利于开发，提高开发效率 1）前后端的完全分离，后台不需要考虑前端如何实现，前端也不需要考虑后台用什么技术，真正意义上实现了技术的划分 2）可以同时进行开发：项目开发开始，首先制定前后端数据交互的接口文档（文档中包含了，调取哪个接口或者哪些数据等协议规范），后台把接口先写好（目前很多公司也需要前端自己拿NODE来模拟这些接口），客户端按照接口调取即可，后台再去实现接口功能即可 【弊端】 不利于SEO优化：第一次从服务器端获取的内容不包含需要动态绑定的数据，所以页面的源代码中没有这些内容，不利于SEO收录，后期通过JS添加到页面中的内容，并不会写在页面的源代码中（是源代码不是页面结构） 交由客户端渲染，首先需要把页面呈现，然后在通过JS的异步AJAX请求获取数据，在进行数据绑定，浏览器再把动态增加的部分重新渲染，无形中浪费了一些时间，没有服务器端渲染页面呈现速度快 基于原生JS实现AJAX12]]></content>
      <categories>
        <category>HTTP和AJAX重点知识</category>
      </categories>
      <tags>
        <tag>HTTP和AJAX重点知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS详解1]]></title>
    <url>%2F2018%2F12%2F12%2FCSS%E8%AF%A6%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[CSS的发展历程从HTML被发明开始，样式就以各种形式存在。不同的浏览器结合它们各自的样式语言为用户提供页面效果的控制。最初的HTML只包含很少的显示属性。随着HTML的成长，为了满足页面设计者的要求，HTML添加了很多显示功能。但是随着这些功能的增加，HTML变的越来越杂乱，而且HTML页面也越来越臃肿。于是CSS便诞生了。 CSS 网页的美容师CSS的出现，拯救了混乱的HTML，当让更加拯救了我们web开发者。 让我们的网页更加丰富多彩。 CSS的最大贡献就是： 让 HTML 从样式中解脱苦海， 实现了 HTML 专注去做 结构呈现。 而样式交给 CSS 后，你完全可以放心的早点洗洗睡了！ 而且。。。。。 CSS 做的很出色，如果JavaScript是网页的魔法师，那么CSS它是我们网页的美容师 我想说， 没有不好看的网页，只有不会CSS的前端。 CSS初识CSS(Cascading Style Sheets) 美化样式 CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 引入CSS样式表（书写位置）CSS可以写到那个位置？ 是不是一定写到html文件里面呢？ 内部样式表内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： 12345&lt;head&gt;&lt;style type="text/CSS"&gt; 选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;&lt;/style&gt;&lt;/head&gt; 语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。 type=”text/CSS” 在html5中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。 行内式（内联样式）内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下： 1&lt;标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"&gt; 内容 &lt;/标签名&gt; 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。 外部样式表（外链式）链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下： 123&lt;head&gt; &lt;link href="CSS文件的路径" rel="stylesheet" /&gt;&lt;/head&gt; 注意： link 是个单标签哦!!! 该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下： 123href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 三种样式表总结（位置） 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） CSS样式规则使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下： 12345678在上面的样式规则中:1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。2.属性和属性值以“键值对”的形式出现。3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。4.属性和属性值之间用英文“:”连接。5.多个“键值对”之间用英文“;”进行区分。可以用段落 和 表格的对齐的演示。 选择器（重点）要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器（选择符）。 选择器干啥的？ 选择标签用的 这就用到基础选择器组： CSS基础选择器标签选择器（元素选择器）标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下： 12标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 或者元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。 标签选择器 可以把某一类标签全部选择出来 div span 类选择器类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下： 1.类名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 1标签调用的时候用 class=“类名” 即可。 类选择器最大的优势是可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 小技巧： 121.长名称或词组可以使用中横线来为选择器命名。2.不建议使用“_”下划线来命名CSS选择器。 ​ 输入的时候少按一个shift键; 浏览器兼容问题 (比如使用tips的选择器命名，在IE6是无效的) 能良好区分JavaScript变量命名(JS变量命名是用“”) 13.不要纯数字、中文等命名， 尽量使用英文字母来表示。 命名规范： Web前端开发规范手册 命名是我们通俗约定的，但是没有规定必须用这些常用的命名。 课堂案例： 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; span &#123; font-size: 100px; &#125; .blue &#123; color: blue; &#125; .red &#123; color: red; &#125; .orange &#123; color: orange; &#125; .green &#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class="blue"&gt;G&lt;/span&gt; &lt;span class="red"&gt;o&lt;/span&gt; &lt;span class="orange"&gt;o&lt;/span&gt; &lt;span class="blue"&gt;g&lt;/span&gt; &lt;span class="green"&gt;l&lt;/span&gt; &lt;span class="red"&gt;e&lt;/span&gt; &lt;/body&gt; 多类名选择器我们可以给标签指定多个类名，从而达到更多的选择目的。 注意： 121. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。2. 各个类名中间用空格隔开。 多类名选择器在后期布局比较复杂的情况下，还是较多使用的。 1234&lt;div class="pink fontWeight font20"&gt;亚瑟&lt;/div&gt;&lt;div class="font20"&gt;刘备&lt;/div&gt;&lt;div class="font14 pink"&gt;安其拉&lt;/div&gt;&lt;div class="font14"&gt;貂蝉&lt;/div&gt; id选择器id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下： 1#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。 用法基本和类选择器相同。 id选择器和类选择器区别W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。 类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜 id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。 id选择器和类选择器最大的不同在于 使用次数上。 通配符选择器通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下： 1* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 1234* &#123; margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/&#125; 注意： 这个通配符选择器，就像我们的电影明星中的梦中情人， 想想它就好了，但是它不会和你过日子。 CSS字体样式属性font-size:字号大小font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。具体如下： font-family:字体font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码： p{ font-family:”微软雅黑”;} 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 常用技巧： 1234561. 现在网页中普遍使用14px+。2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。3. 各种字体之间必须使用英文状态下的逗号隔开。4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 CSS Unicode字体在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。 方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。font-family: “\5FAE\8F6F\96C5\9ED1”，表示设置字体为“微软雅黑”。 可以通过escape() 来测试属于什么字体。 字体名称 英文名称 Unicode 编码 宋体 SimSun \5B8B\4F53 新宋体 NSimSun \65B0\5B8B\4F53 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 楷体_GB2312 KaiTi_GB2312 \6977\4F53_GB2312 隶书 LiSu \96B6\4E66 幼园 YouYuan \5E7C\5706 华文细黑 STXihei \534E\6587\7EC6\9ED1 细明体 MingLiU \7EC6\660E\4F53 新细明体 PMingLiU \65B0\7EC6\660E\4F53 为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 font-weight:字体粗细字体加粗除了用 b 和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 1font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。 小技巧： 1数字 400 等价于 normal，而 700 等价于 bold。 但是我们更喜欢用数字来表示。 font-style:字体风格字体倾斜除了用 i 和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： normal：默认值，浏览器会显示标准的字体样式。 italic：浏览器会显示斜体的字体样式。 oblique：浏览器会显示倾斜的字体样式。 小技巧： 1平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。 font:综合设置字体样式 (重点)font属性用于对字体样式进行综合设置，其基本语法格式如下： 1选择器&#123;font: font-style font-weight font-size/line-height font-family;&#125; 123使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 CSS外观属性color:文本颜色color属性用于定义文本的颜色，其取值方式有如下3种： 1.预定义的颜色值，如red，green，blue等。 2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。 3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。 需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。 line-height:行间距ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 一般情况下，行距比字号大7.8像素左右就可以了。 text-align:水平对齐方式1text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下： left：左对齐（默认值） right：右对齐 center：居中对齐 text-indent:首行缩进text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 text-decoration 文本的装饰text-decoration 通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。下划线 也是我们链接自带的 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 开发者工具（chrome）此工具是我们的必备工具，以后代码出了问题，我们首先第一反应就是： “按F12”或者是 “shift+ctrl+i” 打开 开发者工具。 菜单： 右击网页空白出—查看 小技巧： ctrl+滚轮 可以 放大开发者工具代码大小。 左边是HTML元素结构 右边是CSS样式。 右边CSS样式可以改动数值和颜色查看更改后效果。 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。 交集选择器交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 1比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。 并集选择器并集选择器（CSS选择器分组）是各个选择器通过逗号连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 记忆技巧： 并集选择器 和 的意思， 就是说，只要逗号隔开的，所有选择器都会执行后面样式。 1比如 .one, p , #test &#123;color: #F00;&#125; 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 后代选择器后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 子元素选择器子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。 白话： 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。 1比如： .demo &gt; h3 &#123;color: red;&#125; 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 测试题123456789101112131415161718&lt;div class="nav"&gt; &lt;!-- 主导航栏 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;公司首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司产品&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;公司邮箱&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;公司电话&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class="sitenav"&gt; &lt;!-- 侧导航栏 --&gt; &lt;div class="site-l"&gt;左侧侧导航栏&lt;/div&gt; &lt;div class="site-r"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; 在不修改以上代码的前提下，完成以下任务： 链接 登录 的颜色为红色,同时主导航栏里面的所有的链接改为蓝色 (简单) 主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑。（中等) 主导航栏里面的一级菜单链接文字颜色为绿色。（难) 伪类选择器 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 1为了和我们刚才学的类选择器相区别， 类选择器是一个点 比如 .demo &#123;&#125; 而我们的伪类 用 2个点 就是 冒号 比如 :link&#123;&#125; 链接伪类选择器 :link / 未访问的链接 / :visited / 已访问的链接 / :hover / 鼠标移动到链接上 / :active / 选定的链接 / 注意写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。 love hate 爱上了讨厌 记忆法 或者 lv 包包 非常 hao 12345678a &#123; /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray; &#125;a:hover &#123; /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */&#125; CSS注释1CSS规则是使用 /* 需要注释的内容 */ 进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。 例如： 123p &#123; font-size: 14px; /* 所有的字体是14像素大小*/&#125; sublime快捷方式sublime可以快速提高我们代码的书写方式 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 就可以了 比如 div3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 ​ 标签显示模式（display）同理，我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。 标签的类型(显示模式) HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下： 块级元素(block-level)每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 1常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。 1常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。（a特殊） 注意： 只有 文字才 能组成段落 因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 链接里面不能再放链接。 块级元素和行内元素区别12345块级元素的特点：（1）总是从新行开始（2）高度，行高、外边距以及内边距都可以控制。（3）宽度默认是容器的100%（4）可以容纳内联元素和其他块元素。 12345行内元素的特点：（1）和相邻行内元素在一行上。（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。（3）默认宽度就是它本身内容的宽度。（4）行内元素只能容纳文本或则其他行内元素。 行内块元素（inline-block）123456在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。行内块元素的特点：（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。 标签显示模式转换 display块转行内：display:inline; 行内转块：display:block; 块、行内元素转换为行内块： display: inline-block; 此阶段，我们只需关心这三个，其他的是我们后面的工作。 CSS书写规范开始就形成良好的书写规范，是你专业化的开始。 空格规范【强制】 选择器 与 { 之间必须包含空格。 示例： .selector { } 【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例： font-size: 12px; 选择器规范【强制】 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 示例： 123456789101112/* good */.post,.page,.comment &#123; line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123; line-height: 1.5;&#125; 【建议】 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： 1234567/* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login #username input &#123;&#125;.comment div * &#123;&#125; 属性规范【强制】 属性定义必须另起一行。 示例： 12345678/* good */.selector &#123; margin: 0; padding: 0;&#125;/* bad */.selector &#123; margin: 0; padding: 0; &#125; 【强制】 属性定义后必须以分号结尾。 示例： 123456789/* good */.selector &#123; margin: 0;&#125;/* bad */.selector &#123; margin: 0&#125; CSS 三大特性层叠 继承 优先级 是我们学习CSS 必须掌握的三个特性。 CSS层叠性所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。 一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠 1CSS最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 CSS继承性所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 1CSS最后的执行口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞。 注意： 1恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性） CSS优先级定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。 在考虑权重时，初学者还需要注意一些特殊的情况，具体如下： 1234567继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。 CSS特殊性（Specificity）关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下： specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 继承或者* 的贡献值 0,0,0,0 每个元素（标签）贡献值为 0,0,0,1 每个类，伪类贡献值为 0,0,1,0 每个ID贡献值为 0,1,0,0 每个行内样式贡献值 1,0,0,0 每个!important贡献值 ∞ 无穷大 权重是可以叠加的 比如的例子： 123456789div ul li ------&gt; 0,0,0,3.nav ul li ------&gt; 0,0,1,2a:hover -----—&gt; 0,0,1,1.nav a ------&gt; 0,0,1,1 #nav p -----&gt; 0,1,0,1 ​ ​ 注意： 1.数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 继承的 权重是 0 总结优先级： 使用了 !important声明的规则。 内嵌在 HTML 元素的 style属性里面的声明。 使用了 ID 选择器的规则。 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。 使用了元素选择器的规则。 只包含一个通用选择器的规则。 同一类选择器则遵循就近原则。 1总结：权重是优先级的算法，层叠是优先级的表现 CSS 背景(background)CSS 可以添加背景颜色和背景图片，以及来进行图片设置。 background-color 背景颜色 background-image 背景图片地址 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景固定还是滚动 背景的合写（复合属性） background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 背景图片(image)语法： 1background-image : none | url (url) 参数： none : 无背景图（默认的）url : 使用绝对或相对地址指定背景图像 background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺（repeat）语法： 1background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数： repeat : 背景图像在纵向和横向上平铺（默认的） no-repeat : 背景图像不平铺 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 背景位置(position)语法： 123background-position : length || lengthbackground-position : position || position 参数： length : 百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位position : top | center | bottom | left | center | right 说明： 设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。 注意： position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top; 则 15px 一定是 x坐标 top是 y坐标。 实际工作用的最多的，就是背景图片居中对齐了。 背景附着语法： 1background-attachment : scroll | fixed 参数： scroll : 背景图像是随对象内容滚动fixed : 背景图像固定 说明： 设置或检索背景图像是随对象内容滚动还是固定的。 背景简写background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写： background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 1background: transparent url(image.jpg) repeat-y scroll 50% 0 ; 背景透明(CSS3)CSS3支持背景半透明的写法语法格式是: 1background: rgba(0,0,0,0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。 导航栏案例使用技巧：在一行内的盒子内，我们设定行高等于盒子的高度，就可以使文字垂直居中。 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; body &#123; background-color: #000; &#125; a &#123; width: 200px; height: 50px; /* background-color: orange; */ display: inline-block; /* 把a 行内元素转换为行内块元素 */ text-align: center; /* 文字水平居中 */ line-height: 50px; /* 我们设定行高等于盒子的高度，就可以使文字垂直居中 */ color: #fff; font-size: 22px; text-decoration: none; /* 取消下划线 文本装饰 */ &#125; a:hover &#123; /* 鼠标经过 给我们的链接添加背景图片*/ background: url(images/h.png) no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="#"&gt;专区说明&lt;/a&gt; &lt;a href="#"&gt;申请资格&lt;/a&gt; &lt;a href="#"&gt;兑换奖励&lt;/a&gt; &lt;a href="#"&gt;下载游戏&lt;/a&gt; &lt;/body&gt; 盒子模型（CSS重点）其实，CSS就三个大模块： 盒子模型 、 浮动 、 定位，其余的都是细节。要求这三部分，无论如何也要学的非常精通。 所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。 看透网页布局的本质网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？ 牛奶是怎样运输，让消费者购买的呢？ 我们说过，行内元素比如 文字 类似牛奶，也需要一个盒子把他们装起来，我们前面学过的双标签都是一个盒子。有了盒子，我们就可以随意的，自由的，摆放位置了。 看透网页布局的本质： 把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。 CSS 其实没有太多逻辑可言 ， 类似我们小时候玩的积木,我们可以自由的，随意的摆放出我们想要的效果。 盒子模型（Box Model）这里略过 老旧的ie盒子模型（IE6以下），对不起，我都没见过IE5的浏览器。 首先，我们来看一张图，来体会下什么是盒子模型。 所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。 盒子边框（border）边框就是那层皮。 橘子皮。。柚子皮。。橙子皮。。。 语法： 1border : border-width || border-style || border-color 边框属性—设置边框样式（border-style） 边框样式用于定义页面中边框的风格，常用属性值如下： 123456789none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线 dotted：边框为点线double：边框为双实线 盒子边框写法总结表 设置内容 样式属性 常用属性值 上边框 border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; 下边框 border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; 左边框 border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; 右边框 border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; 样式综合设置 border-style:上边 [右边 下边 左边]; none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 宽度综合设置 border-width:上边 [右边 下边 左边]; 像素值 颜色综合设置 border-color:上边 [右边 下边 左边]; 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%) 边框综合设置 border:四边宽度 四边样式 四边颜色; 表格的细线边框以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 让我们真的相信，CSS就是我们的白马王子（白雪公主）。 table{ border-collapse:collapse; } collapse 单词是合并的意思 border-collapse:collapse; 表示边框合并在一起。 圆角边框(CSS3)从此以后，我们的世界不只有矩形。radius 半径（距离） 语法格式： 1border-radius: 左上角 右上角 右下角 左下角; 内边距（padding）padding属性用于设置内边距。 是指 边框与内容之间的距离。 padding-top:上内边距 padding-right:右内边距 padding-bottom:下内边距 padding-left:左内边距 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1个值 padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 2个值 padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 3个值 padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 4个值 padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 课堂案例： 新浪导航 外边距（margin）margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。 margin-top:上外边距 margin-right:右外边距 margin-bottom:下外边距 margin-left:上外边距 margin:上外边距 右外边距 下外边距 左外边 取值顺序跟内边距相同。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足一下两个条件： 必须是块级元素。 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto，就可使块级元素水平居中。 实际工作中常用这种方式进行网页布局，示例代码如下： 1.header&#123; width:960px; margin:0 auto;&#125; 文字盒子居中图片和背景区别 文字水平居中是 text-align: center 盒子水平居中 左右margin 改为 auto 12text-align: center; /* 文字居中水平 */margin: 10px auto; /* 盒子水平居中 左右margin 改为 auto 就阔以了 */ 插入图片 我们用的最多 比如产品展示类 背景图片我们一般用于小图标背景 或者 超大背景图片 12345678910111213141516section img &#123; width: 200px;/* 插入图片更改大小 width 和 height */ height: 210px; margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */ margin-left: 50px; /* 插入当图片也是一个盒子 */ &#125;aside &#123; width: 400px; height: 400px; border: 1px solid purple; background: #fff url(images/sun.jpg) no-repeat; background-size: 200px 210px; /* 背景图片更改大小只能用 background-size */ background-position: 30px 50px; /* 背景图片更该位置 我用 background-position */ &#125; 清除元素的默认内外边距为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： 1234* &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */&#125; 注意： 行内元素是只有左右外边距的，是没有上下外边距的。 内边距，在ie6等低版本浏览器也会有问题。 我们尽量不要给行内元素指定上下的内外边距就好了。 外边距合并使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案： 避免就好了。 嵌套块元素垂直外边距的合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。 解决方案： 可以为父元素定义1像素的上边框或上内边距。 可以为父元素添加overflow:hidden。 待续。。。。 content宽度和高度使用宽度属性width和高度属性height可以对盒子的大小进行控制。 width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。 大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是： 123456/*外盒尺寸计算（元素空间尺寸）*/Element空间高度 = content height + padding + border + marginElement 空间宽度 = content width + padding + border + margin/*内盒尺寸计算（元素实际大小）*/Element Height = content height + padding + border （Height为内容高度）Element Width = content width + padding + border （Width为内容宽度） 注意： 1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。 2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。 3、如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小。 盒子模型布局稳定性开始学习盒子模型，同学们最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？ 答案是： 其实他们大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。 但是，总有一个最好用的吧，我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 1width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 ​ 盒子阴影语法格式： 1box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 但是不能写 默认 想要内阴影 inset 123456789div &#123; width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, .4); &#125; 浮动(float)普通流(normal flow)这个单词很多人翻译为 文档流 ， 字面翻译 普通流 或者标准流都可以。 前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？ CSS的定位机制有3种：普通流（标准流）、浮动和定位。 html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 浮动(float)浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。 后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。（CSS3已经我们真正意义上的网页布局，具体CSS3我们会详细解释） 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。 在CSS中，通过float属性来定义浮动，其基本语法格式如下： 1选择器&#123;float:属性值;&#125; 属性值 描述 left 元素向左浮动 right 元素向右浮动 none 元素不浮动（默认值） 浮动详细内幕特性浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。 1浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 1浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。 1由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。 1元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。 总结： 浮动 —&gt; 浮动的目的就是为了让多个块级元素同一行上显示。 float 浮 漏 特 浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。 版心和布局流程阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。 “版心”(可视区) 是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。 布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 1、确定页面的版心（可视区）。 2、分析页面中的行模块，以及每个行模块中的列模块。 3、制作HTML结构 。 4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 一列固定宽度且居中 最普通的，最为常用的结构 两列左窄右宽型 比如小米 小米官网 通栏平均分布型 比如锤子 锤子官网 清除浮动人生就像乘坐北京地铁一号线： 途经国贸，羡慕繁华； 途经天安门，幻想权力； 途经金融街，梦想发财； 经过公主坟，遥想华丽家族； 经过玉泉路，依然雄心勃勃… 这时，有个声音飘然入耳:乘客你好,八宝山马上就要到了！ 顿时醒悟：人生苦短，有始有终。 好比我们的浮动，有浮动开始，则就应该有浮动结束。 为什么要清除浮动我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好 。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。 准确地说，并不是清除浮动，而是清除浮动后造成的影响 如果浮动一开始就是一个美丽的错误，那么请用正确的方法挽救它。 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 清除浮动的方法其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下： 1选择器&#123;clear:属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 额外标签法1是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解） 1可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动:after 方式为空元素的升级版，好处是不用单独加标签了 使用方法： 123.clearfix:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。 使用before和after双伪元素清除浮动使用方法： 12345678910.clearfix:before,.clearfix:after &#123; content:""; display:table; /* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */&#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 Photoshop基本使用PS界面组成：菜单栏、选项栏、工具栏、浮动面板（拖拽名称，可单独操作面板）、绘图窗口​ 窗口菜单，可显示隐藏所有面板 工作区：（新建） 调整浮动面板 图层操作(重点) 图层面板快捷键 F7 其实图层就是一张张透明的纸 可以实现叠加问题。 图层选择： 使用移动工具V 1、图层缩览图判断 2、按住CTRL,在目标图像上单击 3、将光标放置在目标图像上右键，选择图层名称 图层面板中加选图层： 1、按SHIFT，单击另一目标图层 中间所有图层被选中 2、按CTRL，单击另一目标图层 只选中目标图层 复制图层：选中目标图层后（移动工具状态下） 1、按ALT拖拽图像 2、CTRL+J （重合） 案例： 摆放一个自行车 图层编组选中目标图层，CTRL+G 取消编组：CTRL+SHIFT+G 双击图层名称可重新命名 双击组名称，可命名组 移动工具V选择组或图层时，需设置选项栏 图层上下位置移动1、选中目标图层，在图层面拖拽 2、CTRL+] 向上移动图层​ CTRL+[ 向下移动图层 3、CTRL+SHIFT+] 图层置顶​ CTRL+SHIFT+[ 图层置底 移动选区或图像时： 移动过程中，没释放鼠标，按住SHIFT，可同一水平线、同一垂线、45度移动。 ps中的撤销操作是： ctrl+z 撤销一步 ctrl+alt+z 撤销多步 Photoshop 切图PS切图 可以 分为 手动 利用切片切图 以及 利用PS的插件快速切图 切片工具 利用切片工具手动划出 图层菜单—新建基于图层的切片 利用标尺 基于参考线的切片 （选择切片工具） ​ 先选个一个整个的切片， 切片选择工具– 属性面板中有 “划分” –可以等分数平分切图 导出切片： 文件– 存储为web设备所用格式 辅助线和切片使用及清除视图菜单– 清除 辅助线/ 清除切片 切图插件Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。 官网: http://www.cutterman.cn/zh/cutterman 注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。 项目案例： 云道页面案例练习目的是总结以前的css和html 还有ps的使用。 制作步骤： 准备相关文件。（内部样式表) html文件(index.html) 图片文件 准备CSS 初始化。 书写结构和样式 确定版心（是1200像素)和各个模块。 定位(position)如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。 PS: 定位是我们CSS算是数一数二难点的了，但是，你务必要学好它，我们CSS离不开定位，特别是后面的js特效，天天和定位打交道。不要抵触它，反而要爱上它，它可以让我们工作更加轻松哦！ 为什么要用定位？那么定位，最长运用的场景再那里呢？ 来看几幅图片，你一定会有感悟！ 第一幅图， 小黄色块可以再图片上移动： 第二幅图， 左右箭头压住图片： 第三幅图, hot 再盒子外面多出一块，更加突出： 以上三个小地方，如果用标准流或者浮动，实现会比较复杂或者难以实现，此时我们用定位来做，just soso！ 元素的定位属性元素的定位属性主要包括定位模式和边偏移两部分。 1、边偏移 边偏移属性 描述 top 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom 底部偏移量，定义元素相对于其父元素下边线的距离 left 左侧偏移量，定义元素相对于其父元素左边线的距离 right 右侧偏移量，定义元素相对于其父元素右边线的距离 也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px; left: 30px; 等等 2、定位模式(定位的分类) 在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下： 选择器{position:属性值;} position属性的常用值 值 描述 static 自动定位（默认定位方式） relative 相对定位，相对于其原文档流的位置进行定位 absolute 绝对定位，相对于其上一个已经定位的父元素进行定位 fixed 固定定位，相对于浏览器窗口进行定位 静态定位(static)静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。 上面的话翻译成白话： 就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。 在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。 PS： 静态定位其实没啥可说的。 相对定位relative(自恋型)12小笑话： 刚刚看到一个超级超级帅的帅哥，看得我都忍不住想和他搞基了。世间怎会有如此之完美的男人。我和他就这样一动不动的对视着，就仿佛一见钟情。时间也在这一瞬间停止了。直到我的手麻了。才恋恋不舍的放下镜子。。。。 相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。 对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示： 注意： 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。 其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置） 就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标） 如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。 绝对定位absolute (拼爹型)1234567小笑话：吃早饭时，老婆往儿子碗里放了两个煎蛋，儿子全给了我，还一本正经地说：“爸爸，多吃点，男人养家不容易。” &lt;br/&gt;我一阵感动，刚想夸他两句。 儿子接着说：“以后全靠你让我拼爹了！” [注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。 当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。 注意： 绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。 父级没有定位若所有父元素都没有定位，以浏览器为准对齐(document文档)。 父级有定位绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 子绝父相这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。 这句话的意思是 子级是绝对定位的话， 父级要用相对定位。 首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。 就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。 但是，在我们网页布局的时候， 最常说的 子绝父相是怎么来的呢？ 请看如下图： 所以，我们可以得出如下结论： 因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。 父盒子布局时，需要占有位置，因此父亲只能是 相对定位. 这就是子绝父相的由来。 绝对定位的盒子水平/垂直居中普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了 定位的盒子也可以水平或者垂直居中，有一个算法。 首先left 50% 父盒子的一半大小 然后走自己外边距负的一半值就可以了 margin-left。 ​ 固定定位fixed(认死理型)固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。 当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。 固定定位有两点： 固定定位的元素跟父亲没有任何关系，只认浏览器。 固定定位完全脱标，不占有位置，不随着滚动条滚动。 记忆法： 就类似于孙猴子， 无父无母，好不容易找到一个可靠的师傅（浏览器），就听的师傅的，别的都不听。 ie6等低版本浏览器不支持固定定位。 叠放次序（z-index）当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。 在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。 比如： z-index: 2; 注意： z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。 如果取值相同，则根据书写顺序，后来居上。 后面数字一定不能加单位。 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。 四种定位总结 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 不脱标，占有位置 可以 相对自身位置移动（自恋型） 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置（拼爹型） 固定定位fixed 完全脱标，不占有位置 可以 相对于浏览器移动位置（认死理型） 定位模式转换跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式， 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。 元素的显示与隐藏在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。 他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！ display 显示display 设置或检索对象是否及如何显示。 display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： 隐藏之后，不再保留位置。 visibility 可见性设置或检索是否显示对象。 visible : 对象可视 hidden : 对象隐藏 特点： 隐藏之后，继续保留原有位置。（停职留薪） overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 visible : 不剪切内容也不添加滚动条。 auto : 超出自动显示滚动条，不超出不显示滚动条 hidden : 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll : 不管超出内容否，总是显示滚动条 CSS高级技巧CSS用户界面样式 所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 1cursor : default 小白 | pointer 小手 | move 移动 | text 文本 鼠标放我身上查看效果哦： 123456&lt;ul&gt; &lt;li style="cursor:default"&gt;我是小白&lt;/li&gt; &lt;li style="cursor:pointer"&gt;我是小手&lt;/li&gt; &lt;li style="cursor:move"&gt;我是移动&lt;/li&gt; &lt;li style="cursor:text"&gt;我是文本&lt;/li&gt;&lt;/ul&gt; 尽量不要用hand 因为 火狐不支持 pointer ie6以上都支持的尽量用 轮廓 outline 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 1outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。 最直接的写法是 ： outline: 0; 或者 outline: none; 1&lt;input type="text" style="outline: 0;"/&gt; 防止拖拽文本域resizeresize：none 这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。 右下角可以拖拽： 右下角不可以拖拽： 1&lt;textarea style="resize: none;"&gt;&lt;/textarea&gt; vertical-align 垂直对齐以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto; 以前我们还讲过让文字居中对齐，是 text-align: center; 但是我们从来没有讲过有垂直居中的属性， 我们的妈妈一直很担心我们的垂直居中怎么做。 vertical-align 垂直对齐， 这个看上去很美好的一个属性， 实际有着不可捉摸的脾气，否则我们也不会这么晚来讲解。 1vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， 通常用来控制图片/表单与文字的对齐。 图片、表单和文字对齐所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。 去除图片底侧空白缝隙有个很重要特性你要记住： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。这样会造成一个问题，就是图片底侧会有一个空白缝隙。 解决的方法就是： 给img vertical-align:middle | top等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 溢出的文字隐藏word-break:自动换行normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 主要处理英文单词 white-spacewhite-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 normal : 默认处理方式nowrap : 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。 可以处理中文 text-overflow 文字溢出text-overflow : clip | ellipsis 设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 clip : 不显示省略标记（…），而是简单的裁切 ellipsis : 当对象内文本溢出时显示省略标记（…） 注意一定要首先强制一行内显示，再次和overflow属性 搭配使用 #CSS精灵技术（sprite） 小妖精 雪碧 精灵技术产生的背景 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。 精灵技术本质简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图（雪碧图），如下图所示为京东网站中的一个精灵图。 精灵技术的使用CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。 制作精灵图CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。 大部分情况下，精灵图都是网页美工做。 1234我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。我们精灵图的宽度取决于最宽的那个背景。 我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。 结束语： 小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。 滑动门先来体会下现实中的滑动门,或者你可以叫做推拉门： 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。 核心技术核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： 12345&lt;li&gt; &lt;a href="#"&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 学成在线综合案例字体图标图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新”宠幸”啦。。 这就是字体图标（iconfont). 字体图标优点12345可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...本身体积更小，但携带的信息并没有削减。几乎支持所有的浏览器移动端设备必备良药... 字体图标使用流程总体来说，字体图标按照如下流程： 设计字体图标假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图： 之后保存为svg格式，然后给我们前端人员就好了。 其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。 上传生成字体包 当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。 ​ 推荐网站： http://icomoon.io icomoon字库 IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 推荐网站： http://www.iconfont.cn/ 阿里icon font字库 http://www.iconfont.cn/ 这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！ fontello http://fontello.com/ 在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。 Font-Awesome http://fortawesome.github.io/Font-Awesome/ 这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。 Glyphicon Halflings http://glyphicons.com/ 这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。 Icons8 https://icons8.com/ 提供PNG免费下载，像素大能到500PX 下载兼容字体包刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了 当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。 字体引入到HTML得到压缩包之后，最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。 首先把 以下4个文件放入到 fonts文件夹里面。 通俗的做法 第一步：在样式里面声明字体： 告诉别人我们自己定义的字体12345678910@font-face &#123; font-family: 'icomoon'; src: url('fonts/icomoon.eot?7kkyc2'); src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?7kkyc2') format('truetype'), url('fonts/icomoon.woff?7kkyc2') format('woff'), url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg'); font-weight: normal; font-style: normal;&#125; 第二步：给盒子使用字体123span &#123; font-family: "icomoon"; &#125; 第三步：盒子里面添加结构12345span::before &#123; content: "\e900"; &#125;或者 &lt;span&gt;&lt;/span&gt; 追加新图标到原来库里面如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标，但是原来的不能删除，继续使用，此时我们需要这样做 把压缩包里面的selection.json 从新上传，然后，选中自己想要新的图标，从新下载压缩包，替换原来文件即可。 京东项目(一)京东项目介绍项目名称：京东网项目描述：京东首页公共部分的头部和尾部制作，京东首页中间部分。 项目背景现阶段电商类网站很流行，很多同学毕业之后会进入电商类企业工作，同时电商类网站需要的技术也是较为复杂的，这里用京东电商网站复习、总结、提高前面所学布局技术。其实，最主要的原因还是，为啥写京东？ 因为刘强东，赚了我们的钱，抢了我们的女神， 我们也要学刘强东，赚别人的钱，抢别人..额，自己的女神。。。 设计目标 保证浏览器 ie7及以上, 火狐, 360, safari，chrome等。谁让我再测ie6，就跟谁急。。 熟悉CSS+DIV布局，页面的搭建工作 了解常用电商类网站的布局模式 为后期京东移动端做铺垫 几点思考(1). 开发工具 sublime 、fireworks（ps）、各种浏览器(ie6.7 要测看心情) (2). CSS Rest 类库,为跨浏览器兼容做准备(也可以直接运用jd网站的初始化) 1234567891011normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。 你值得拥有。。 - 保护有用的浏览器默认样式而不是完全去掉它们- 一般化的样式：为大部分HTML元素提供- 修复浏览器自身的bug并保证各浏览器的一致性- 优化CSS可用性：用一些小技巧- 解释代码：用注释和详细的文档来 (3). 技术栈 1HTML5 结构 + CSS3 布局 (因为我们就会这些。。。嘻嘻) (4). 低版本浏览器 单独制作一个跳转页面 (都是孩子，也舍不得打，舍不得扔) https://h5.m.jd.com/dev/3dm8aE4LDBNMkDfcCaRxLnVQ7rqo/index.html 目录说明要实现结构和样式相分离的设计思想。 根目录下有这4个文件（目录）。 名称 说明 css 用于存放CSS文件 images 用于存放图片 index 京东首页 HTML js 用于后期存放javascript文件 运用知识点引入ico图标 1代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;/&gt; 注意： 她(它)不是iconfont字体哦。 位置是放到 head 标签中间。 后面的type=”image/x-icon” 属性可以省略。（我相信你也愿意省略。） 为了兼容性，请将favicon.ico 这个图标放到根目录下。（我们就不要任性了，听话放位置，省很多麻烦。。你好，我也好） 转换ico图标我们可以自己做的图片，转换为 ico图标，以便放到我们站点里面。 http://www.bitbug.net/ 网站优化三大标签SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”！SEO是指通过对网站进行站内优化、网站结构调整、网站内容建设、网站代码优化等)和站外优化，从而提高网站的关键词排名以及公司产品的曝光度。 简单的说就是，把产品做好，搜索引擎就会介绍客户来。 我们现在阶段主要进行站内优化。网站优化，我们应该要懂。。。 网页title 标题title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。 建议： 首页标题：网站名（产品名）- 网站的介绍 例如： 京东(JD.COM)-综合网购首选-正品低价、品质保障、配送及时、轻松购物！ 小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站 Description 网站说明对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。 京东网： 1&lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt; 注意点： 描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。 同样遵循简短原则，字符数含空格在内不要超过 120 个汉字。 补充在 title 和 keywords 中未能充分表述的说明. 用英文逗号 关键词1,关键词2 1&lt;meta name=&quot;description&quot; content=&quot;小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。&quot; /&gt; Keywords 关键字Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。 京东网： 1&lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot; /&gt; 小米网： 1&lt;meta name=&quot;keywords&quot; content=&quot;小米,小米6,红米Note4,小米MIX,小米商城&quot; /&gt; 顶部（快捷菜单）所用知识点 知识点 说明 通栏的盒子 不用给宽度 默认为 100% &nbsp;但是加了浮动和定位的盒子需要 添加 100% 盒子居中对齐 margin: auto; 注意必须有宽度的块级元素，文字水平居中对齐是 text-align:center; 行高会继承 文字性质的，比如 颜色、文字大小、字体、行高等会继承父级元素 浮动元素、固定定位，绝对定位会模式转换 具有行内块特性，比如一行放多个，有高度和宽度，如果没有指定宽度，则会根据内容多少撑开。 logo 和搜索 header 区域所用知识点网页布局稳定性 宽度剩余法： 知识点 说明 浮动元素特性 1. 浮动可以让多个元素同一行显示 2. 浮动的元素是顶部对齐 logo优化 text-indent: -20000px; 隐藏文字， 背景图片 清除浮动 清除浮动的目的就是为了解决父亲高度为0的问题 鼠标样式 cursor: pointer; 小手 cursor: move; 四角箭头 cursor: text; 插入光标 cursor: default; 小白 不允许换行 white-space: nowrap; nav导航栏所用知识点 名称 说明 边框底侧 border-bottom: 2px solid #ccc; 定位重点 绝对定位不占位置 相对定位占有位置 标签语义化dl dl也是块级元素 dt 是 定义标题 dd 是定义描述，dd是围绕这dt来描述的，也就是说，dd算是dt 的解释说明详细分解。 标题标签h 尽量少用h1，可以多用h2和h3等标签 页面底部所用知识点 名称 说明 绝对定位的盒子居中对齐 盒子 left 50% 然后通过 margin 负值自己的宽度一半（固定定位也是如此） 固定定位的盒子靠近版心右侧对齐跟绝对定位的盒子居中对齐原理差不多。 left 50% 然后 margin-left 版心宽度一半。 学习目标: 掌握京东中间部分制作 理解BFC使用 了解优雅降级和渐进增强 了解CSS压缩和验证工具 typora-copy-images-to: media 京东项目(二)nav导航栏所用知识点 名称 说明 边框底侧 border-bottom: 2px solid #ccc; 定位重点 绝对定位不占位置 相对定位占有位置 标签语义化dl dl也是块级元素 dt 是 定义标题 dd 是定义描述，dd是围绕这dt来描述的，也就是说，dd算是dt 的解释说明详细分解。 标题标签h 尽量少用h1，可以多用h2和h3等标签 固定定位的盒子靠近版心右侧对齐跟绝对定位的盒子居中对齐原理差不多。 left 50% 然后 margin-left 版心宽度一半。 焦点图部分所用知识点 名称 说明 圆角矩形 border-radius: 左上角 右上角 右下角 左下角。 负值自己的宽度一半（固定定位也是如此） 背景半透明1.强烈推荐： background: rgba(r,g,b,alpha); ​ r,g,b 是红绿蓝的颜色， alpha 是透明度的意思，取值范围是 0~1 之间。 2.了解ie低版本浏览器 半透明 filter:Alpha(opacity=50) ； // opacity值为0 到 100 但是 此属性是盒子半透明，不是背景半透明哦，因为里面的内容也一起半透明了 因此，低版本的 ie6.7浏览器，我们不需要透明了，直接采用优雅降级的做法。 background: gary; background: rgba(0,0,0,.2); 写上两句 背景， 低版本ie只执行gray， 其他浏览器执行 半透明下面这一句。 BFC(块级格式化上下文)BFC(Block formatting context) 直译为”块级格式化上下文”。 元素的显示模式我们前面讲过 元素的显示模式 display。 分为 块级元素 行内元素 行内块元素 ，其实，它还有很多其他显示模式。 那些元素会具有BFC的条件不是所有的元素模式都能产生BFC，w3c 规范： display 属性为 block, list-item, table 的元素，会产生BFC. 大家有么有发现这个三个都是用来布局最为合理的元素，因为他们就是用来可视化布局。 注意其他的，display属性，比如 line 等等，他们创建的是 IFC ，我们暂且不研究。 这个BFC 有着具体的布局特性： 有宽度和高度 ， 有 外边距margin 有内边距padding 有边框 border。 就好比，你有了练习武术的体格了。 有潜力，有资质。 什么情况下可以让元素产生BFC以上盒子具有BFC条件了，就是说有资质了，但是怎样触发才会产生BFC，从而创造这个封闭的环境呢？ 在好比，你光有资质还不行，你需要一定额外效果才能出发的武学潜力，要么你掉到悬崖下面，捡到了一本九阴真经，要么你学习葵花宝典，欲练此功必先…. 同样，要给这些元素添加如下属性就可以触发BFC。 -float属性不为none -position为absolute或fixed -display为inline-block, table-cell, table-caption, flex, inline-flex -overflow不为visible。 BFC元素所具有的特性BFC布局规则特性： 1.在BFC中，盒子从顶端开始垂直地一个接一个地排列. 2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠 3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 白话文： 孩子在家里愿意怎么折腾都行，但是出了家门口，你就的乖乖的，不能影响外面的任何人。 BFC的主要用途BFC能用来做什么？ (1) 清除元素内部浮动 只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。 主要用到 1计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 (2) 解决外边距合并问题 外边距合并的问题。 主要用到 1盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠 属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。 (3) 制作右侧自适应的盒子问题 主要用到 1普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文 BFC 总结BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。 优雅降级和渐进增强什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？ 渐进增强 progressive enhancement： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 类似 爬山，由低出往高处爬 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 类似蹦极，由高处往低处下落 区别：渐进增强是向上兼容，优雅降级是向下兼容。 个人建议： 现在互联网发展很快， 连微软公司都抛弃了ie浏览器，转而支持 edge这样的高版本浏览器，我们很多情况下没有必要再时刻想着低版本浏览器了，而是一开始就构建完整的效果，根据实际情况，修补低版本浏览器问题。 浏览器前缀 浏览器前缀 浏览器 -webkit- Google Chrome, Safari, Android Browser -moz- Firefox -o- Opera -ms- Internet Explorer, Edge -khtml- Konqueror 后面我们会有 常用的解决H5和C3 的兼容解决文件， 我们这里暂且不涉及。 背景渐变在线性渐变过程中，颜色沿着一条直线过渡：从左侧到右侧、从右侧到左侧、从顶部到底部、从底部到顶部或着沿任何任意轴。如果你曾使用过制作图件，比如说Photoshop，你对线性渐变并不会陌生。 兼容性问题很严重，我们这里之讲解线性渐变 语法格式： 1background:-webkit-linear-gradient(渐变的起始位置， 起始颜色， 结束颜色)； 1background:-webkit-linear-gradient(渐变的起始位置， 颜色 位置， 颜色位置....)； CSS W3C 统一验证工具CssStats 是一个在线的 CSS 代码分析工具 1网址是： http://www.cssstats.com/ 如果你想要更全面的，这个神奇，你值得拥有： W3C 统一验证工具： http://validator.w3.org/unicorn/ ☆☆☆☆☆ 因为它可以检测本地文件哦！！ HTML5新标签与特性 文档类型设定 document HTML: sublime 输入 html:4s XHTML: sublime 输入 html:xt HTML5 sublime 输入 html:5 &lt;!DOCTYPE html&gt; 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 w3c 手册中文官网 : http://w3school.com.cn/ header：定义文档的页眉 头部 nav：定义导航链接的部分 footer：定义文档或节的页脚 底部 article：定义文章。 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容 侧边 123456&lt;header&gt; 语义 :定义页面的头部 页眉&lt;/header&gt;&lt;nav&gt; 语义 :定义导航栏 &lt;/nav&gt; &lt;footer&gt; 语义: 定义 页面底部 页脚&lt;/footer&gt;&lt;article&gt; 语义: 定义文章&lt;/article&gt;&lt;section&gt; 语义： 定义区域&lt;/section&gt;&lt;aside&gt; 语义： 定义其所处内容之外的内容 侧边&lt;/aside&gt; ​ datalist 标签定义选项列表。请与 input 元素配合使用该元素 123456789&lt;input type="text" value="输入明星" list="star"/&gt; &lt;!-- input里面用 list --&gt;&lt;datalist id="star"&gt; &lt;!-- datalist 里面用 id 来实现和 input 链接 --&gt; &lt;option&gt;刘德华&lt;/option&gt; &lt;option&gt;刘若英&lt;/option&gt; &lt;option&gt;刘晓庆&lt;/option&gt; &lt;option&gt;郭富城&lt;/option&gt; &lt;option&gt;张学友&lt;/option&gt; &lt;option&gt;郭郭&lt;/option&gt;&lt;/datalist&gt; ​ fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用 12345&lt;fieldset&gt; &lt;legend&gt;用户登录&lt;/legend&gt; 标题 用户名: &lt;input type="text"&gt;&lt;br /&gt;&lt;br /&gt; 密 码: &lt;input type="password"&gt;&lt;/fieldset&gt; ​ 新增的input type属性值： 类型** 使用示例** 含义** email** 输入邮箱格式 tel** 输入手机号码格式 url** 输入url格式 number** 输入数字格式 search** 搜索框（体现语义化） range** 自由拖动滑块 time** 小时分钟 date** 年月日 datetime** 时间 month** 月年 week** 星期 年 常用新属性 属性** 用法** 含义** placeholder** 占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回 autofocus** 规定当页面加载时 input 元素应该自动获得焦点 multiple** 多文件上传 autocomplete** 规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 2.这个表单您必须给他名字 required** 必填项 内容不能为空 accesskey** 规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 综合案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案&lt;/legend&gt; &lt;label for="userName"&gt;姓名:&lt;/label&gt; &lt;input type="text" name="userName" id="userName" placeholder="请输入用户名"&gt; &lt;br&gt; &lt;label for="userPhone"&gt;手机号码:&lt;/label&gt; &lt;input type="tel" name="userPhone" id="userPhone" pattern="^1\d&#123;10&#125;$"&gt;&lt;br&gt; &lt;label for="email"&gt;邮箱地址:&lt;/label&gt; &lt;input type="email" required name="email" id="email"&gt;&lt;br&gt; &lt;label for="collage"&gt;所属学院:&lt;/label&gt; &lt;input type="text" name="collage" id="collage" list="cList" placeholder="请选择"&gt;&lt;br&gt; &lt;datalist id="cList"&gt; &lt;option value="前端与移动开发学院"&gt;&lt;/option&gt; &lt;option value="java学院"&gt;&lt;/option&gt; &lt;option value="c++学院"&gt;&lt;/option&gt; &lt;/datalist&gt;&lt;br&gt; &lt;label for="score"&gt;入学成绩:&lt;/label&gt; &lt;input type="number" max="100" min="0" value="0" id="score"&gt;&lt;br&gt; &lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案思密达&lt;/legend&gt; &lt;label&gt;姓名: &lt;input type="text" placeholder="请输入学生名字"/&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;手机号: &lt;input type="tel" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;邮箱: &lt;input type="email" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;所属学院: &lt;input type="text" placeholder="请选择学院" list="xueyuan"/&gt; &lt;datalist id="xueyuan"&gt; &lt;option&gt;java学院&lt;/option&gt; &lt;option&gt;前端学院&lt;/option&gt; &lt;option&gt;php学院&lt;/option&gt; &lt;option&gt;设计学院&lt;/option&gt; &lt;/datalist&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;出生日期: &lt;input type="date" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;成绩: &lt;input type="number" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;毕业时间: &lt;input type="date" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type="submit" /&gt; &lt;input type="reset" /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;label for="inTime"&gt;入学日期:&lt;/label&gt; &lt;input type="date" id="inTime" name="inTime"&gt;&lt;br&gt; &lt;label for="leaveTime"&gt;毕业日期:&lt;/label&gt; &lt;input type="date" id="leaveTime" name="leaveTime"&gt;&lt;br&gt; &lt;input type="submit"&gt; &lt;/fieldset&gt;&lt;/form&gt; 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 embed（会使用）embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。 因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 1&lt;embed src="http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; 优酷，土豆，爱奇艺，腾讯、乐视等等 先上传 在分享 多媒体 audioHTML5通过标签来解决音频播放的问题。 使用相当简单，如下图所示 并且可以通过附加属性可以更友好控制音频的播放，如： autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 如果这个属性不写 默认播放一次 loop 或者 loop = “loop” 表示无限循环 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图 标签允许您规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择 多媒体 videoHTML5通过标签来解决音频播放的问题。 同音频播放一样，使用也相当简单，如下图 同样，通过附加属性可以更友好的控制视频的播放 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图** CSS3 新增选择器结构(位置)伪类选择器（CSS3) :first-child :选取属于其父元素的首个子元素的指定选择器 :last-child :选取属于其父元素的最后一个子元素的指定选择器 :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型 :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式 ​ 123456789li:first-child &#123; /* 选择第一个孩子 */ color: pink; &#125;li:last-child &#123; /* 最后一个孩子 */ color: purple; &#125;li:nth-child(4) &#123; /* 选择第4个孩子 n 代表 第几个的意思 */ color: skyblue; &#125; 目标伪类选择器(CSS3) :target目标伪类选择器 :选择器可用于选取当前活动的目标元素 1234:target &#123; color: red; font-size: 30px;&#125; 属性选择器选取标签带有某些特殊属性的选择器 我们成为属性选择器 12345678910/* 获取到 拥有 该属性的元素 */div[class^=font] &#123; /* class^=font 表示 font 开始位置就行了 */ color: pink; &#125;div[class$=footer] &#123; /* class$=footer 表示 footer 结束位置就行了 */ color: skyblue; &#125;div[class*=tao] &#123; /* class*=tao *= 表示tao 在任意位置都可以 */ color: green; &#125; 1234567891011&lt;div class="font12"&gt;属性选择器&lt;/div&gt; &lt;div class="font12"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="24font"&gt;属性选择器123&lt;/div&gt; &lt;div class="sub-footer"&gt;属性选择器footer&lt;/div&gt; &lt;div class="jd-footer"&gt;属性选择器footer&lt;/div&gt; &lt;div class="news-tao-nav"&gt;属性选择器&lt;/div&gt; &lt;div class="news-tao-header"&gt;属性选择器&lt;/div&gt; &lt;div class="tao-header"&gt;属性选择器&lt;/div&gt; 伪元素选择器（CSS3) E::first-letter文本的第一个单词或字（如中文、日文、韩文等） E::first-line 文本第一行； E::selection 可改变选中文本的样式； 1234567891011121314p::first-letter &#123; font-size: 20px; color: hotpink;&#125;/* 首行特殊样式 */p::first-line &#123; color: skyblue;&#125;p::selection &#123; /* font-size: 50px; */ color: orange;&#125; 4、E::before和E::after 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。 123456div::befor &#123; content:"开始";&#125;div::after &#123; content:"结束";&#125; E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。 “:” 与 “::” 区别在于区分伪类和伪元素 之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。是伪元素在html代码机构中的展现，可以看出无法伪元素的结构无法审查 注意 伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的content属性，表示伪元素的内容,设置:before和:after时必须设置其content属性，否则伪元素就不起作用。 背景缩放(CSS3)通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。 其参数设置如下： a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高） b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多 c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。 1234background-image: url('images/gyt.jpg'); background-size: 300px 100px; /* background-size: contain; */ /* background-size: cover; */ 多背景(CSS3)以逗号分隔可以设置多背景，可用于自适应布局 做法就是 用逗号隔开就好了。 一个元素可以设置多重背景图像。 每组属性间使用逗号分隔。 如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。 为了避免背景色将图像盖住，背景色通常都定义在最后一组上， 123background:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px , url(test1.jpg) no-repeat scroll 10px 20px/70px 90px , url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa; ​ 凹凸文字12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; div &#123; color: #ccc; font: 700 80px "微软雅黑"; &#125; div:first-child &#123; /* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */ text-shadow: 1px 1px 1px #000, -1px -1px 1px #fff; &#125; div:last-child &#123; /* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */ text-shadow: -1px -1px 1px #000, 1px 1px 1px #fff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是凸起的文字&lt;/div&gt; &lt;div&gt;我是凹下的文字&lt;/div&gt; &lt;/body&gt; CSS3盒模型CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况： 1、box-sizing: content-box 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode 2、box-sizing: border-box 盒子大小为 width 就是说 padding 和 border 是包含到width里面的 注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。 12345678910111213141516171819div:first-child &#123; width: 200px; height: 200px; background-color: pink; box-sizing: content-box; /* 就是以前的标准盒模型 w3c */ padding: 10px; border: 15px solid red; /* 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode */ &#125; div:last-child &#123; width: 200px; height: 200px; background-color: purple; padding: 10px; box-sizing: border-box; /* padding border 不撑开盒子 */ border: 15px solid red; /* margin: 10px; */ /* 盒子大小为 width 就是说 padding 和 border 是包含到width里面的 */&#125; 过渡(CSS3)过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片 在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。 语法格式: 12transition: 要过渡的属性 花费时间 运动曲线 何时开始;如果有多组属性变化，还是用逗号隔开。 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 如果想要所有的属性都变化过渡， 写一个all 就可以 transition-duration 花费时间 单位是 秒 s 比如 0.5s 这个s单位必须写 ms 毫秒 运动曲线 默认是 ease 何时开始 默认是 0s 立马开始 运动曲线示意图： 1234567891011121314151617div &#123; width: 200px; height: 100px; background-color: pink; /* transition: 要过渡的属性 花费时间 运动曲线 何时开始; */ transition: width 0.6s ease 0s, height 0.3s ease-in 1s; /* transtion 过渡的意思 这句话写到div里面而不是 hover里面 */ &#125;div:hover &#123; /* 鼠标经过盒子，我们的宽度变为400 */ width: 600px; height: 300px&#125;transition: all 0.6s; /* 所有属性都变化用all 就可以了 后面俩个属性可以省略 */ 2D变形(CSS3) transformtransform是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、倾斜、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。 变形转换 transform transform 变换 变形的意思 《 transformers 变形金刚》 移动 translate(x, y)translate 移动平移的意思 1translate(50px,50px); 使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。 可以改变元素的位置，x、y可为负值； 123translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）translateX(x)仅水平方向移动（X轴移动）translateY(Y)仅垂直方向移动（Y轴移动） 123456789.box &#123; width: 499.9999px; height: 400px; background: pink; position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); /* 走的自己的一半 */&#125; 让定位的盒子水平居中 缩放 scale(x, y) 1transform:scale(0.8,1); 可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。 123scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）scaleX(x)元素仅水平方向缩放（X轴缩放）scaleY(y)元素仅垂直方向缩放（Y轴缩放） scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大 旋转 rotate(deg)可以对元素进行旋转，正值为顺时针，负值为逆时针； 1transform:rotate(45deg); 注意单位是 deg 度数 transform-origin可以调整元素转换变形的原点 1div&#123;transform-origin: left top;transform: rotate(45deg); &#125; /* 改变元素原点到左上角，然后进行顺时旋转45度 */ 如果是4个角，可以用 left top这些，如果想要精确的位置， 可以用 px 像素。 1div&#123;transform-origin: 10px 10px;transform: rotate(45deg); &#125; /* 改变元素原点到x 为10 y 为10，然后进行顺时旋转45度 */ 案例旋转楚乔传 123456789101112131415161718192021222324252627282930313233343536div &#123; width: 250px; height: 170px; border: 1px solid pink; margin: 200px auto; position: relative; &#125; div img &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; transition: all 0.6s; transform-origin: top right; &#125; div:hover img:nth-child(1) &#123; /* 鼠标经过div 第一张图片旋转 */ transform: rotate(60deg); &#125; div:hover img:nth-child(2) &#123; transform: rotate(120deg); &#125; div:hover img:nth-child(3) &#123; transform: rotate(180deg); &#125; div:hover img:nth-child(4) &#123; transform: rotate(240deg); &#125; div:hover img:nth-child(5) &#123; transform: rotate(300deg); &#125; div:hover img:nth-child(6) &#123; transform: rotate(360deg); &#125; 倾斜 skew(deg, deg) 1transform:skew(30deg,0deg); 该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。 可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。 3D变形(CSS3) transform2d x y 3d x y z 左手坐标系 伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图 CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图 简单记住他们的坐标： x左边是负的，右边是正的 y 上面是负的， 下面是正的 z 里面是负的， 外面是正的 rotateX() 就是沿着 x 立体旋转. 1234567img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateY()沿着y轴进行旋转 1234567img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateZ()沿着z轴进行旋转 123456789img &#123; transition:all .25s ease-in 0s;&#125;img:hover &#123; /* transform:rotateX(180deg); */ /* transform:rotateY(180deg); */ /* transform:rotateZ(180deg); */ /* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */&#125; 透视(perspective)电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。 透视可以将一个2D平面，在转换的过程当中，呈现3D效果。 透视原理： 近大远小 。 浏览器透视：把近大远小的所有图像，透视在屏幕上。 perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置 注：并非任何情况下需要透视效果，根据开发需要进行设置。 perspective 一般作为一个属性，设置给父元素，作用于所有3D转换的子元素 理解透视距离原理： translateX(x)仅水平方向移动**（X轴移动） 主要目的实现移动效果 translateY(y)仅垂直方向移动（Y轴移动） translateZ(z)transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。 translate3d(x,y,z)[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值 开门案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061body &#123;&#125;.door &#123; width: 300px; height: 300px; margin: 100px auto; border: 1px solid gray; perspective: 1000px; background: url('images/dog.gif') no-repeat cover; position: relative;&#125;.door &gt; div &#123; box-sizing: border-box; border: 1px solid black;&#125;.left &#123; float: left; width: 50%; height: 100%; background-color: brown; transform-origin: left center; transition: 1s; position: relative;&#125;.left::before &#123; content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; right: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;&#125;.right &#123; width: 50%; height: 100%; float: left; background-color: brown; transform-origin: right center; transition: 1s; position: relative;&#125;.right::before &#123; content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; left: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;&#125;.door:hover .left &#123; transform: rotateY(-130deg);&#125;.door:hover .right &#123; transform: rotateY(130deg);&#125; backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。 翻转盒子案例12345678910111213141516171819div &#123; width: 224px; height: 224px; margin: 100px auto; position: relative; &#125; div img &#123; position: absolute; top: 0; left: 0; transition: all 1s; &#125; div img:first-child &#123; z-index: 1; backface-visibility: hidden; /* 不是正面对象屏幕，就隐藏 */ &#125; div:hover img &#123; transform: rotateY(180deg);&#125; 动画(CSS3) animation动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 语法格式： 1animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向; 关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意r 1234@keyframes 动画名称 &#123; from&#123; 开始位置 &#125; 0% to&#123; 结束 &#125; 100%&#125; 12animation-iteration-count:infinite; 无限循环播放animation-play-state:paused; 暂停动画&quot; 小汽车案例123456789101112131415161718192021222324252627body &#123; background: white;&#125;img &#123; width: 200px;&#125;.animation &#123; animation-name: goback; animation-duration: 5s; animation-timing-function: ease; animation-iteration-count: infinite;&#125;@keyframes goback &#123; 0%&#123;&#125; 49%&#123; transform: translateX(1000px); &#125; 55%&#123; transform: translateX(1000px) rotateY(180deg); &#125; 95%&#123; transform: translateX(0) rotateY(180deg); &#125; 100%&#123; transform: translateX(0) rotateY(0deg); &#125;&#125; 伸缩布局(CSS3)CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向 侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的 方向：默认主轴从左向右，侧轴默认从上到下 主轴和侧轴并不是固定不变的，通过flex-direction可以互换。 Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多 2、各属性详解** 1.flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 min-width 最小值 min-width: 280px 最小宽度 不能小于 280 max-width: 1280px 最大宽度 不能大于 1280 2.flex-direction调整主轴方向（默认为水平方向） flex-direction: column 垂直排列 flex-direction: row 水平排列 http://m.ctrip.com/html5/ 携程网手机端地址 3、justify-content调整主轴对齐（水平对齐） 子盒子如何在父盒子里面水平对齐 值 描述 白话文 flex-start 默认值。项目位于容器的开头。 让子元素从父容器的开头开始排序但是盒子顺序不变 flex-end 项目位于容器的结尾。 让子元素从父容器的后面开始排序但是盒子顺序不变 center 项目位于容器的中心。 让子元素在父容器中间显示 space-between 项目位于各行之间留有空白的容器内。 左右的盒子贴近父盒子，中间的平均分布空白间距 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 相当于给每个盒子添加了左右margin外边距 4、align-items调整侧轴对齐（垂直对齐） 子盒子如何在父盒子里面垂直对齐（单行） 值 描述 白话文 stretch 默认值。项目被拉伸以适应容器。 让子元素的高度拉伸适用父容器（子元素不给高度的前提下) center 项目位于容器的中心。 垂直居中 flex-start 项目位于容器的开头。 垂直对齐开始位置 上对齐 flex-end 项目位于容器的结尾。 垂直对齐结束位置 底对齐 5、flex-wrap控制是否换行 当我们子盒子内容宽度多于父盒子的时候如何处理 值 描述 nowrap 默认值。规定灵活的项目不拆行或不拆列。 不换行，则 收缩（压缩） 显示 强制一行内显示 wrap 规定灵活的项目在必要的时候拆行或拆列。 wrap-reverse 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。 6、flex-flow是flex-direction、flex-wrap的简写形式 1flex-flow: flex-direction flex-wrap; 白话记： flex-flow: 排列方向 换不换行; 两个中间用空格 例如： 1234display: flex;/* flex-direction: row;flex-wrap: wrap; 这两句话等价于下面的这句话*/flex-flow: column wrap; /* 两者的综合 */ 7、align-content堆栈（由flex-wrap产生的独立行）多行垂直对齐方式齐 align-content是针对flex容器里面多轴(多行)的情况,align-items是针对一行的情况进行排列。 必须对父元素设置自由盒属性display:flex;，并且设置排列方式为横向排列flex-direction:row;并且设置换行，flex-wrap:wrap;这样这个属性的设置才会起作用。 值 描述 测试 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 8、order控制子项目的排列顺序，正序方式排序，从小到大 用css 来控制盒子的前后顺序。 用order 就可以 用整数值来定义排列顺序，数值小的排在前面。可以为负值。 默认值是 0 1order: 1; 此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值 文字阴影(CSS3)以后我们可以给我们的文字添加阴影效果了 Shadow 影子 1text-shadow:水平位置 垂直位置 模糊距离 阴影颜色; 前两项是必须写的。 后两项可以选写。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML详解1]]></title>
    <url>%2F2018%2F12%2F11%2FHTML%E8%AF%A6%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[HTML 第一天目标能够写出基本的页面（里面包含图片、各种标签和链接） 开发工具我们主要用的 开发工具有 chrome 、 sublime 、 photoshop 浏览器（显示）1浏览器是网页显示、运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 查看浏览器占有的市场份额（知晓）查看网站： http://tongji.baidu.com/data/browser 这些工具你认识几个？ sublime（书写） 普通青年 Dreamweaver 文艺青年 sublime 高手和傻子 用记事本 其实。。。。 Photoshop(协助)PS 工具是我们使用频率比较高的软件之一， 我们学习PS目的不是为了设计海报做电商和UI的，而是要求： 熟练的切图 能和网站美工美眉有共同话题。。。。。 认识网页1网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。 1思考： 网页是如何形成的呢? 常见浏览器内核介绍1浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 浏览器内核（理解）12345浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 （1）Trident(IE内核) 国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 （2）Gecko(firefox) Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 （3） webkit(Safari) Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， （4） Chromium/Blink(chrome) 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 ​ 大部分国产浏览器最新版都采用Blink内核。二次开发 （5） Presto(Opera) Presto（已经废弃） 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。 1了解一点： 移动端的浏览器内核主要说的是系统内置浏览器的内核。 Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。 iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的 Web标准（重点）通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。 1问： 哪个语言再全国基本都可以听得懂？ Web 标准的好处1、让Web的发展前景更广阔2、内容能被更广泛的设备访问3、更容易被搜寻引擎搜索4、降低网站流量费用5、使网站更易于维护6、提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 123结构标准：结构用于对网页元素进行整理和分类，咱们主要学的是HTML。 最重要表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript 理想状态我们的源码： .HTML .css .js 直观感受： 总结WEB标准： 结构标准： 决定你是否有个好天然身体 表现标准： 决定你是否打扮的美丽外观 行为标准： 决定你是否有吸引人的行为 课堂一练：1.关于WEB标准下列说法正确的是: A html决定页面的行为，css决定页面的样式，js决定页面的结构 B html决定页面的样式，css决定页面的结构，js决定页面的行为 C html决定页面的结构，css决定页面的样式，js决定页面的行为 D 以上都不正确 2 web 标准里边规定三层分离不包括哪部分 A．HTML B．CSS C．JavaScript D．PHP 3.关于WEB标准下列说法正确的是 A．html相当于人的动作行为，CSS相当于人的穿着打扮，javascript相当于人的骨架结构； B．html相当于人的骨架结构，CSS相当于人的穿着打扮，javascript相当于人的动作行为； C．html相当于人的穿着打扮，CSS相当于人的骨架结构，javascript相当于人的动作行为； D．html相当于人的骨架结构，CSS相当于人的动作行为，javascript相当于人的穿着打扮； HTML 初识一般先学习HTML+CSS， 这里我们先定一个小目标，先学HTML,后学习CSS。 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”。是用来描述网页的一种语言。 所谓超文本，因为它可以加入图片、声音、动画、多媒体等内容，不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接。 1&lt;h1&gt; 我是一个大标题 &lt;/h1&gt; 注意： 体会 文本 标签 语言 几个词语 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) 总结： HTML 作用就是用标记标签来描述网页，把网页内容在浏览器中展示出来。 用文字来描述网页标签 HTML骨架格式日常生活的书信，我们要遵循共同的约定。 同理：HTML 有自己的语言语法骨架格式： 1234567&lt;HTML&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/HTML&gt; 课堂练习1： 书写我们的第一个HTML 页面！ 新建一个demo 的 TXT 文件。 里面写入刚才的HTML 骨架。月薪过万 你我之间 黑马洗练 一飞冲天 把后缀名改为 .HTML。 右击–谷歌浏览器打开。 12345678910111213141516171 HTML标签：作用所有HTML中标签的一个根节点。 最大的标签 根标签2 head标签： 文档的头部文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。注意在head标签中我们必须要设置的标签是title3.title标签： 文档的标题作用：让页面拥有一个属于自己的标题。4.body标签：文档的主体 以后我们的页面内容 基本都是放到body里面的body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） 为了便于记忆，我们请出刚才要辞职回家养猪的二师兄来帮忙， 我称之为 猪八戒记忆法 HTML标签分类 在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML骨架结构标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素 1.双标签 1&lt;标签名&gt; 内容 &lt;/标签名&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 12&gt; 比如 &lt;body&gt;我是文字 &lt;/body&gt;&gt; 2.单标签 1&lt;标签名 /&gt; 单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 12&gt; 比如 &lt;br /&gt;&gt; HTML标签关系标签的相互关系就分为两种： 1.嵌套关系 1&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 2.并列关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。 课堂一练1请问下列哪个标签是错误的？ 1A &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 1B &lt;strong&gt;&lt;div&gt;&lt;/div&gt;&lt;/strong&gt; 1C &lt;head&gt;&lt;title&gt;&lt;/head&gt;&lt;/title&gt; 1D &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 1234再页面中输入 以下2个单词1. html: 5 2. ! 在sublime里面然后按下tab键盘即可生成HTML骨架 文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; 同学你用啥手机？你咋回答？ 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。 &lt;!DOCTYPE&gt; 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 1记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。 HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 白话，一眼看去，就知道那个是重点，结构是什么，知道每块的内容是干啥的。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML常用标签 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 (熟记) 单词缩写： head 头部. 标题 title 文档标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 &lt;h1&gt;&lt;/h1&gt; ...&lt;h6&gt;&lt;/h6&gt; 1标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： 1&lt;hn&gt; 标题文本 &lt;/hn&gt; 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用，或者页面中最重要标题信息。 段落标签( 熟记)单词缩写： paragraph 段落 [ˈpærəgræf] 无须记这个单词 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 1&lt;p&gt; 文本内容 &lt;/p&gt; 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识)单词缩写： horizontal 横线 [ˌhɔrəˈzɑntl] 同上 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 1&lt;hr /&gt;是单标签 在网页中显示默认样式的水平线。 课堂练习2： 新闻页面 换行标签(熟记)单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1&lt;br /&gt; 这时如果还像在word中直接敲回车键换行就不起作用了。 课堂一练关于标签下列说法正确的是 (A) P1是段落标签 (B) H1 是标题标签 (C) Hr是换行标签 (D) Br 是一条直线 2 关于标签下列说法不正确的是 (A) H标签有6个等级分别是&lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt;和&lt;h6&gt; (B) h1到h6 文字从小到大 (C) p标签一行只能放一个 (D) P是段落标签会给文字加上段落的语义 div span标签(重点)div span 是没有语义的 是我们网页布局主要的2个盒子 css+div div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span, 跨度，跨距；范围 语法格式： 1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt;今日价格&lt;/span&gt; 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。 手机的颜色是黑色 手机的尺寸是 8寸 水平线的长度是 200 图片的宽度 是 300 键 值对 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 1&lt;标签名 属性1="属性值1" 属性2="属性值2" …&gt; 内容 &lt;/标签名&gt; 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=”value” 的格式 比如: 1&lt;hr width="400" /&gt; 属性 是 宽度 值 是 400 提倡： 尽量不使用 样式属性。 图像标签img (重点)单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 1&lt;img src="图像URL" /&gt; 当网页显示图片时,鼠标滑上图片显示文字描述是以下哪个属性** (A) 设置alt属性 (B) 设置title属性 (C) 设置href 属性 (D) 设置src 属性 2 在HTML中，使用标签插入图像，下列选项关于的src属性说法正确的是 (A) 用来设置图片的格式 (B) 用来设置图片的所在位置 (C) 用来设置鼠标指向图片时显示的文字 (D) 用来设置图片是否能正确显示 链接标签(重点)单词缩写： anchor 的缩写 [ˈæŋkə(r)] 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt; href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点）通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步： 123451.使用“a href=”#id名&gt;“链接文本"&lt;/a&gt;创建链接文本（被点击的） &lt;a href="#two"&gt; 2.使用相应的id名标注跳转目标的位置。 &lt;h3 id="two"&gt;第2集&lt;/h3&gt; base 标签 基本的base 可以设置整体链接的打开状态 base 写到 之间 把所有的连接 都默认添加 target=”_blank” 课堂一练 1在HTML中，关于a标签说法不正确的是（） (A) a标签可以通过href属性跳转到另外一个页面 (B) a标签可以通过targer属性设置在是否在新窗口中打开 (C) a标签只能在当前页面设置锚点链接，让用户能够快速定位到目标内 (D) a标签可以通过href=”#”设置一个空链接 2如果想跳转到当前页面里名为show的锚点，下列写法是正确的 A &lt; a href=”.show”&gt;跳转 B &lt; a href=”#show”&gt;跳转 C &lt; a href=” show”&gt;跳转 D &lt; a src=” #show”&gt;跳转 3如果想跳转到同目录下的名为success.html文件里名为show的锚点，下列写法是正确的 (A) &lt; a href=”success.html#show”&gt;跳转 (B) &lt; a href=”#show”&gt;跳转 (C) &lt; a href=”success#show”&gt;跳转(D) &lt; a src=”success.html#show”&gt;跳转 特殊字符标签 （理解） 注释标签在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; ctrl + / 或者 ctrl +shift + / 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 注释重要性： 路径(重点、难点) 实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。 根目录 当前目录 路径可以分为： 相对路径和绝对路径 相对路径以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的 “D:\web\img\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 课堂一练1.在下面结构中，哪种写法可以在index页面中有输出img.gif (A) &lt;img src=&quot;../image/img.gif&quot; /&gt; (B) &lt;img src=&quot;image/img.gif&quot; /&gt; (C) &lt;img src=&quot;image../img.gif&quot; /&gt; (D) &lt;img src=&quot;img.gif/image&quot; /&gt; 2在下面结构中，哪种写法可以在index页面中有输出1.jpg (A) &lt;img src=&quot;../1/2/1.jpg&quot; /&gt; (B) &lt;img src=&quot;/1/2/1.jpg&quot; /&gt; (C) &lt;img src=&quot;1/2/1.jpg&quot; /&gt; (D) &lt;img src=&quot;1.jpg&quot; /&gt; 3在下面结构中哪种写法可以在index页面中有输出img.gif (A) &lt;img src=&quot;demo/image/img.gif&quot; /&gt; (B) &lt;img src=&quot;image/img.gif&quot; /&gt; (C) &lt;img src=&quot;image../img.gif&quot; /&gt; (D) &lt;img src=&quot;img.gif/image/demo&quot; /&gt; 总结 每一天都有一个主题 我们HTML第一天的主题就是 &lt;认识标签&gt; 学HTML 之前 觉得 很神秘 等你学完之后忽然发现 总结今天的思路贯穿线： 列表标签什么是列表？ 把…制成表,以表显示 容器里面装载着文字或图表的一种形式，叫列表。 列表最大的特点就是 整齐 、整洁、 有序 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 1231. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解）有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol img src=”HTML详解1/1.jpg” /&gt; 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 用的还可以： 表格 table(会使用) 存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。 ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释 123451.table用于定义一个表格。2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。 注意： 11. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 12. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素 表格属性 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构（了解）12345678910在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。 表格标题表格的标题： caption 定义和用法 caption 元素定义表格标题。 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 合并单元格(难点)跨行合并：rowspan 跨列合并：colspan 合并单元格的思想： ​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。 ​ 公式： 删除的个数 = 合并的个数 - 1 合并的顺序 先上 先左 总结表格 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 ​ 表格的学习要求： 能手写表格结构，并且能合并单元格。 表单标签(掌握)现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图 目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 控件(重点)在上面的语法中，&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。 label标签(理解)label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 12&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; textarea控件(文本域)如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 123&lt;textarea cols="每行中的字符数" rows="显示的行数"&gt; 文本内容&lt;/textarea&gt; 下拉菜单使用select控件定义下拉菜单的基本语法格式如下 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件&lt;/form&gt; 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 查文档经常查阅文档是一个非常好的学习习惯。 W3C : http://www.w3school.com.cn/ MDN: https://developer.mozilla.org/zh-CN/ 一、计算机基础知识1.1 文件和文件夹管理 熟练掌握文件和文件夹的管理，包括创建、删除、重命名、复制、粘贴、剪切、移动。 熟练掌握“文件拓展名”的意义 在windows下，所有的文件的名字，是两部分组成的。语法： 文件名.拓展名 拓展名一般就是2~4个字母，表示文件的格式。比如.jpg是图片格式，.mp3音乐格式，.doc文档。 一般来说，操作系统，是不能显示拓展名的，需要我们自己设置。我们以win7举例： 知道“打开方式”的意义一个文件，可以用多种软件打开，这就叫做打开方式。实际上现在你就应该树立一种思维，同一个文件可以用不同的软件打开。比如，.jpg用“照片查看器”打开，就是浏览模式；用画图打开，就是编辑模式。 会使用桌面，知道“快捷方式”的概念所有快捷方式，都有一个小箭头图标。就是一个快捷入口，所以删除这个图标，程序还在。 1.2 特殊按键和快捷键键盘上除了有字母、数字之外，还有一些特殊的按键：ctrl、shift、alt、tab● ctrl键是英语control“控制”的意思，这个按键，单独按没有任何作用，都要和其他的按键一起按才有用。比如ctrl+c，表示同时按住ctrl键和c键，一会儿将知道这个功能是复制。● shift键是英语shift“换挡”的意思，按下这个按键同时击打字母，打出的就是大写字母。熟悉shift键来打大写字母，尽量少用大小写锁定键。● alt键是英语alternate“调整”的意思，和ctrl一样，自己按没啥用，都要和其他的按键一起按才有用。比如alt+f4，表示关闭当前的窗口，比如你正在玩儿游戏，老板来了，可以按alt+f4快速关闭窗口。● tab键是用于table“制表符”的意思，经常实现“切换的功能”。比如我们在word软件中同时打开了两个文档，可以用ctrl+tab键，来在两个文档之间切换。 当然，可以用alt+tab键来切换程序。 必须熟练掌握下面的快捷键：ctrl+c 复制ctrl+v 粘贴ctrl+x 剪切（就是移动文件，在原来的文件夹ctrl+x一个文件，然后在新文件夹中ctrl+v粘贴）ctrl+tab 切换（具体切换什么，要看是什么软件）alt+F4 关闭程序F2 重命名F5 刷新，比如看网页的时候，想刷新网页，按f5ctrl+z 撤销，就是这一步干错了，就ctrl+z撤销windows+E 打开资源管理器windows+D 显示桌面ctrl+空格 切换中英文，严禁用shift键切换 二、互联网的原理2.1 上网就是请求数据网页上的内容，怎么就被我们看见了？什么是上网？我们先不直接解决这个问题，我们做一个小实验。我们每个人的电脑里面，都有一个神秘的文件夹：C:\Users\ufo\AppData\Local\Microsoft\Windows\Temporary Internet Files这个文件夹叫做临时文件夹（文件夹知道存在就可以了，不用自己试着去找）蓝色部分是每个人不一样的我们清空这个文件夹中的全部内容 我们打开IE浏览器，看几个网页。结果，这个文件夹中又多了很多的内容： 通过这个实验，目前为止，我们可以得出结论，上网的时候，是有真实的、物理的文件传输的！ 所以我们经常感觉第二次打开网页，比第一次快，这是因为第一次打开网页的时候，所有的图片都已经存过来了。所以现在也能够解释，为什么每次都用360能清理一堆垃圾，释放很多硬盘空间。 我们可以回答刚才的问题了，“上网”究竟是是什么？答案：上网就是请求数据，就是文件传输。服务器上存放着网页的相关文件，包括html文件、css文件、js文件、图片等。当我们打开浏览器，输入网址，我们的计算机就会对这些文件发出HTTP请求。​ 服务器收到请求之后，会把这些文件通过HTTP协议，传输到我们的计算机中（保存到了刚才那个临时文件夹中）。这些文件，将在我们计算机本地的浏览器中，进行渲染、呈递。​ 2.2 服务器● 服务器就是计算机，只不过比咱们用的笔记本的配置牛逼了很多，并且24小时不断电，不关机。● 服务器上存储着网页的相关文件。一旦有访问者浏览网站，服务器就将发送这些文件给访问者。● 服务器一旦关机，网站就无法访问了。 2.4 HTTP超文本传输协议，Hypertext Transfer Protocol。这是一个文件的传输协议，我们上网的时候，所有的文件都是通过HTTP这个协议，从服务器上传输到客户的电脑里面的。 网页是真实物理的文件。并且一个网页是很多的物理文件组成的：html文件、图片文件、js文件、css文件。这些文件要通过特殊软件才能上传到服务器上。然后就能让用户看了。用户通过浏览器，访问网址，服务器上面的文件就会通过http请求悄悄地传输到用户的电脑中的临时文件夹中，在用户的电脑中执行、渲染、呈递 三、HTML初步认识3.1 认识什么是纯文本文件txtwindows中自带一个软件，叫做记事本。记事本保存的文档格式就是txt格式，就是英语text的缩写。术语上，称呼这个文件叫做“纯文本文件”。 txt文件，只能保存文本内容，是无法记录文本样式的。所以，doc和txt存储同样的内容，doc比txt大： 纯文本文件就是这样的文件：1） 只有文本，没有样式；2） 用记事本等纯文本编辑器可读，不是乱码html、css、js都是纯本文的。 3.2 HTML是负责描述文档语义的语言HTML是英语HyperText Markup Language的缩写，超文本标记语言。 html提供了很多标签对儿，可以给文本增加不同的语义。比如： 标签对儿，主标题。 标签对儿，二级标题。 标签对儿，普通段落。 现在的业界的标准，网页技术严格的三层分离：html就是负责描述页面的语义；css负责描述页面的样式；js负责描述页面的动态效果的。 所以，html不能让文字居中，不能更改文字字号、字体、颜色。因为这些都是属于样式范畴，都是css干的事儿；html不能让盒子运动起来，因为这些属性行为范畴，都是js干的事儿。html只能干一件事儿，就是通过标签对儿，给文本增加语义。这是html唯一能做的。 html中，除了语义，其他什么都没有。 比如，面试的时候问你，h1标签有什么作用？正确答案：给文本增加主标题的语义错误答案：给文字加粗、加黑、变大 五、HTML骨架和基本语法12345678910111 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;2 &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;3 &lt;head&gt;4 &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt;5 &lt;title&gt;哈哈哈&lt;/title&gt;6 &lt;/head&gt;7 &lt;body&gt;8 &lt;h1&gt;我是一个主标题&lt;/h1&gt;9 &lt;p&gt;我是一个小段落&lt;/p&gt;10 &lt;/body&gt;11 &lt;/html&gt; 第1行，就是网页的声明头，这行语句，千万不要背诵，谁背谁傻。术语叫做DocType Defintion，文档类型定义，简称DTD。这行语句非常的复杂，里面暗含了一个网址。W3C就是出web规范的组织机构。html、css、js的规范都是W3C定义发布的。world wide web coalition , 国际万维网联盟。网页声明头可以告诉浏览器，这是一个什么标准的页面。 第2行，是最大的html标签，所有的网页内容，都要包裹在这个标签对儿里面。 我们发现，html标签中，有两个属性： xmlns=”http://www.w3.org/1999/xhtml&quot; 命名空间，就是一个规范； xml:lang=”en” 语言是英语 第3行，就是head标签，就是配置。 第4行， 字符集的配置 第5行，哈哈哈 网页的标题，可以显示在浏览器的标签栏中。 第7行，body标签就是网页的内容，用户能够看见。 一、复习上节课的内容网页的原理：用户输入网址之后，对应的服务器就发现有人请求我的网页了，所以这个服务器就会把网页和相关的图片、js文件、css文件、flash文件都通过HTTP协议传输到用户的电脑里面。HTML页面在用户的电脑里面进行渲染。HTTP协议指的是超文本传输协议。每一个网址，都对应了服务器上面的确定的文件。 纯文本文件：只有内容，没有样式。常见的纯文本文件有：.txt、.html、.js、.css、.java。没有语义，即使你这个文件中的内容排版再清晰，那也是人认为的，实际上纯文本文件中的所有的文字生而平等，没有任何的语义。 HTML：超文本标记语言，HyperText Markup Language。就是通过标签对儿，给纯文本增加语义。也就是说，用文本给文本增加语义，所以这个叫做“超文本”。而有一对儿对儿标签，也成为“标记”，所以就是“超文本标记语言”。 标签： 主标题的语义 ，h是英语headline标题的意思。 HTML中除了语义，其他什么都没有：没有样式、没有交互、没有行为。 所以HTML不能让文本居中、字号调整、颜色改变、字体、下划线、倾斜…… 二、HTML骨架标准的骨架 123456789101 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;2 &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;3 &lt;head&gt;4 &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt;5 &lt;title&gt;Document&lt;/title&gt;6 &lt;/head&gt;7 &lt;body&gt;8 9 &lt;/body&gt;10 &lt;/html&gt; 2.1 文档声明头任何一个标准的HTML页面，第一行一定是一个以&lt;!DOCTYPE开头的语句。这一行，就是文档声明头，DocType Declaration。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 到底有哪些规范呢？ 首先我们先确定一件事儿，我们现在学习的是HTML4.01这个版本，这个版本是IE6开始兼容的。HTML5是IE9开开始兼容的。但是IE6、7、8这些浏览器还不能过早的淘汰，所以这几年网页还是应该用HTML4.01来制作。后面将知道手机、移动端的网页，就可以使用HTML5了。 HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下面）： HTML4.01里面规定了普通、XHTML两大种规范。 HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？ 所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。 总结一下， 一共有6种DTD，说白了，HTML第一行语句一共有6种： 2.2 字符集有两个字库UTF-8和gb2312。 UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语…… gb2312 是国标，是中国的字库，里面仅涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。 字库规模： UTF-8（字全） &gt; gb2312（只有汉字） UTF-8里面存储一个汉字3个字节。而gb2312中存储一个汉字2个字节。 保存大小： UTF-8（更臃肿、加载更慢） &gt; gb2312 （更小巧，加载更快） 总结： UTF-8 字多，有各种国家的语言，但是保存尺寸大，文件臃肿； gb2312字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。 列出2个使用情形： 1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。 2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。 2.3 关键字和页面描述meta除了可以设置字符集，还可以设置关键字和页面描述。 设置页面描述： 11 &lt;meta name="Description" content="网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。" /&gt; 只要设置的Description页面面熟，那么百度搜索结果，就能够显示这些语句，这个技术叫做SEO，search engine optimization，搜索引擎优化。 2.4 title标签11 &lt;title&gt;网页的标题&lt;/title&gt; title也是有助于SEO搜索引擎优化的： 三、HTML的基本语法特性3.1 HTML对换行不敏感，对tab不敏感HTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。 换不换行、tab不tab，都不影响页面的结构。也就是说，HTML不是依靠缩进来表示嵌套的，就是看标签的包裹关系。但是，我们发现有良好的缩进，代码更易读。要求大家都正确缩进标签。 3.2 空白折叠现象HTML中所有的文字之间，如果有空格、换行、tab都将被折叠为一个空格显示。 3.3 标签要严格封闭标签不封闭是灾难的： 四、h和p标签HTML标签是分等级的，HTML将所有的标签分为两种：容器级、文本级。顾名思义，容器级的标签，里面可以放置任何东西；文本级的标签里面，只能放置文字、图片、表单元素。 五、图片 标准答案：&lt;img src=&quot;../../photo/1.png&quot; /&gt; 解释： 现在document是最大的文件夹，里面有两个文件夹work和photo。work中又有一个文件夹叫做myweb。myweb文件夹里面有index.html。 所以index.html在myweb文件夹里面，上一级就是work文件夹，上两级就是document文件夹。通过document文件夹当做一个中转站，进入photo文件夹，看到了1.png。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP等传输协议讲解]]></title>
    <url>%2F2018%2F12%2F10%2FHTTP%E5%92%8CAJAX%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[成为栈开发工程师需要掌握的技术栈如何成为一名初级全栈开发工程师什么是全栈开发工程师？ 全栈（全站）开发工程师(FULL-STACK)：前后端都可以自己独立完成开发 [前端] HTML（5）+ CSS（3） JAVASCRIPT（JQ，VUE，REACT） [后端] Java (JSP) Python Node PHP C#（.net-&gt;dot net） (ASP.NET) C … [数据库] mysql sql server oracle mongodb （和node结合紧密的） … [自动化] git / svn webpack(基于NODE运行的) 服务器部署工具（iis/Apache/nginx…） linux操作系统 https://insights.stackoverflow.com/survey/2018 真实项目的部署流程(以及一点职业发展建议)前端和后端是如何通信的？ 前端：客户端 后端：服务器端 所谓的全栈，其实就是自己可以实现客户端和服务端程序的编写，而且还可以实现两端之间的通信 职业规划建议： 培养自己的人脉圈，建立自己的影响力 壮大自己的综合能力 经常参加一些活动 开放分享（做讲师分享自己的智慧，写自己的个人博客做技术分享） 自己做一个技术博客 本地开发（当前项目可以在本地预览） 部署到服务器上，让别人可以通过域名或者外网访问 购买一台服务器（阿里云独立主机，虚拟服务器等）https://wanwang.aliyun.com 购买域名 把自己做的项目传到服务器上 让域名和服务器关联(DNS解析：域名解析) 在服务器上发布或部署我们的项目（iis，nginx，apache…） 做一些推广（SEO推广，友情链接交换，技术文章持续更新） 使用FileZilla进行FTP上传 客户端和服务器端是如何通信的？经典面试题：当我们在浏览器地址中输入一个URL地址，到最后看到页面，中间都经历了哪些事情？ [Request 请求阶段] 首先根据客户端输入的域名，到DNS服务器上进行反解析（通过服务器找到对应外网IP） 通过找到的外网IP，找到对应的服务器 通过在地址栏中输入的端口号（没输入是因为不同协议有自己的默认端口号），找到服务器上发布的对应的项目 [Response 响应阶段] 服务器获取到请求资源文件的地址，例如：/books/index.html,把资源文件中的源代码找到 服务器端会把找到的源代码返回给客户端（通过HTTP等传输协议反回的） [浏览器自主渲染] 客户端接收到源代码后，会交给浏览器的内核（渲染引擎）进行渲染，最后有浏览器绘制出对应的页面 客户端和服务器端交互(通信)模型 HTTP等传输协议讲解URL，URI，URN URI：统一资源标识符 URL：统一资源定位 URN： 统一资源名称 URI = URL + URN 一个完整的URL包含很多部分： 例如：https://www.haiyang.com/stu/index.html?name=hy&amp;age=6#good 第一部分：传输协议 传输协议是用来完成客户端和服务端数据（内容）传输的，类似于快递小哥，负责把客户和商家的物品来回传递 客户端不仅可以向服务器发送请求，而且还可以把一些参数传递给服务器 服务器端也可以把内容返回给客户端 客户端和服务器端传输的内容总称为HTTP报文，这些报文信息都是基于传输协议完成传输的，客户端传递给服务器叫做请求（Request），服务器端返回给客户端叫做响应（Response），request+response两个阶段统称为一个HTTP事务（事务：一件完整的事情） HTTP事务： 当客户端向服务器端发送请求。此时客户端和服务器端会建立一个传输通道（链接通道），传输协议就是基于这个通道把信息进行传输的 当服务器端接收到请求信息，把内容返回给客户端后，传输通道会自动关闭 传输协议分类： http:超文本传输协议（客户端和服务器端传输的内容除了文本以外，还可以传输图片，音频，视频等文件流【二进制编码/BASE64码】，以及传输XML格式的数据等），是目前市场上应用最广泛的传输协议 https: http ssl，他比http更加安全，因为数据内容的传输通道是经过ssl加密的（他需要在服务器端进行特殊的处理），所以涉及资金类的网站一般都是https协议的 ftp:资源文件传输协议，一般用于客户端把资源文件（不是代码）上传到服务器端，或者从服务器端下载一些资源文件（一般ftp传输的内容会比http这类协议传输的内容多） HTTP报文的一些核心知识HTTP报文 起始行 请求起始行 响应起始行 首部（头） 请求头：内置请求头，自定义请求头 响应头：内置响应头，自定义响应头 通用头：请求和响应都有的 主体 请求主体 响应主体 请求xxx都是客户端设置的信息，服务端获取这些信息 响应xxx都是服务器端设置的信息，客户端用来接收这些信息 在谷歌浏览器控制台Network选项中，我们可以看见当前客户端和服务器端交互的全部信息 总结： 客户端传递给服务器端数据 URL问号传递参数 设置请求头 设置请求主体 服务器端返回给客户端内容 设置响应头（例如服务器时间） 设置响应主体 第二部分：域名 设置域名其实就是给不好记忆的服务器外网ip设置了一个好记的名字 一级域名（顶级域名）：qq.com 二级域名：www.qq.com，sports.qq.com，。。。 三级域名：kkk.sports.qq.com 第三部分：端口号 在服务器发布项目的时候，我们可以通过端口号区分当前服务器上的不同项目 一台服务器的端口号取值范围：0-65535之间，如果电脑上安装了许多程序，有一些端口号就是被占用了 一个IP地址的端口可以有65536（2^16）个，端口号只有整数，范围是从0 到65535（2^16-1）。 端口有三个类型： \1. 公认端口（Well Known Ports）是众所周知的端口号，范围从0到1023。 \2. 动态端口（Dynamic Ports）范围是从49152到65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。 \3. 注册端口（RegisteredPorts）范围是从1024到49151，分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。 HTTP: 默认端口号80 HTTPS：默认端口号443 FTP：默认端口号21 对于上述三个端口号其实是很重要的，如果被其他程序占用，我们就不能使用了，所以在服务器上一般是禁止安装其他程序的 第四部分：请求资源的文件路径名称 /boos/index.html 在服务器中发布项目的时候，我们一般都会配置一些默认文档，用户即使不输入请求文件的名称，服务器也会找到默认文档（一般默认文档都是 index/default …） 我们通常为了做SEO优化，会把一些动态页面的地址（xxx.py，xxx.jsp，xxx.php …）进行伪URL重写（需要服务器处理的） 例如：https://item.jd.com/342535.html 不可能 有一个商品就写一个详情页，肯定是同一个详情页做不同的处理 第一种方案： 由后台语言根据详情页模板动态生成具体的详情页面 第二种方案： 当前页面就是一个页面，例如：detail.html/detail.php，我们做详情页面的时候，开发是按照detail.html?id=787878来开发的。但是这种页面不方便做SEO优化，此时我们把真实的地址进行重写，重写为我们看到的787878.html 第五部分：问号传参 ?name=hy&amp;age=6 把一些值通过xxx=xxx的方式，放在一个URL的末尾，通过？传递参数 【作用】 在AJAX请求中，我们可以通过问号传递参数的方式，客户端把一些信息传递给服务器，服务器根据传递信息的不一样，返回不同的数据 123456789// $.ajax(url,&#123;&#125;);// $.get(url,function()&#123;&#125;);对于AJAX请求的特殊写法，原理还是基于AJAX方法实现的 $.post / $.script$.ajax(&#123; url: 'getPersonInfo?id=11' ...&#125;);// 当前案例，我们传递给服务器的编号是多少，服务器就会把对应编号的人员返回 消除AJAX请求中GET方式缓存 12345$.ajax(&#123; url: 'xxx?_=0.3434', method: 'get'&#125;);// 我们会在请求URL末尾追加一个随机数 _=随机数，保证每一次请求的URL地址都是不一样的，以此来消除GET请求遗留的缓存问题 通过URL传递参数的方式，可以实现页面之间信息的通信，例如：我们有两个页面A/B，A是列表页面，B是详情页面，点击A中的某一条信息，进入到唯一的详情页B，如何展示不同的信息，这种操作就可以基于URL问号传递参数来实现 例如： http://sports.qq.com/kbsweb/game.html?mid=10000:123 http://sports.qq.com/kbsweb/game.html?mid=10000:125 在进入到game.html页面的时候，我们可以获取URL传递的参数值，根据传递参数值的不一样，从服务器端获取不同的数据展示 在列表页面进行页面跳转的时候，我们需要记住的是跳转的同时传递不同的参数值 &lt;a href=&#39;game.html?mid=xxx&#39; 第六部分：HASH值 /#xxx URL末尾传递的#号就是HASH值（）哈希值 【作用】 页面中锚点定位 前端路由（SPA 单页面开发）]]></content>
      <categories>
        <category>HTTP和AJAX重点知识</category>
      </categories>
      <tags>
        <tag>HTTP和AJAX重点知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux和redux]]></title>
    <url>%2F2018%2F12%2F09%2Freact-redux%E5%92%8Credux%2F</url>
    <content type="text"><![CDATA[redux 原理：统一管理状态redux GitHub地址：https://github.com/reduxjs/redux redux 说明文档：`https://redux.js.org/` createStore 创建容器store来保存状态的的 创建容器需要传一个管理员 reducer（用户自己定义的） state 属性，外界不可以直接访问 getState 外界可以通过store.getState 访问和获取这个状态 dispatch 派发一个动作，内部会调用reducer，通过这个方法修改更新状态state subscribe 定阅事件（当用户派发dispatch的时候，内部会触发订阅的事件执行） 1234567891011121314151617181920212223&gt; &gt; export default function createStore(reducer) &#123;&gt; &gt; let state, listener = [],&gt; &gt; dispatch, subscribe, getState;&gt; &gt; dispatch = (action) =&gt; &#123;&gt; &gt; reducer(state, action);&gt; &gt; listener.forEach(item =&gt; item())&gt; &gt; &#125;;&gt; &gt; dispatch(&#123;&#125;);&gt; &gt; subscribe = (fn) =&gt; &#123;&gt; &gt; listener = [...listener, fn];&gt; &gt; return () &#123;&gt; &gt; listener = listener.filter(item =&gt; item != fn)&gt; &gt; &#125;&gt; &gt; &#125;;&gt; &gt; getState = () =&gt; (JSON.parse(JSON.stringify(state)));&gt; &gt; return &#123;&gt; &gt; dispatch,&gt; &gt; subscribe,&gt; &gt; getState&gt; &gt; &#125;&gt; &gt; &gt; &gt; &#125;&gt; &gt; combineReducers 合并状态，将多个管理员reducer合并成一个 参数 {reducer1，reducer2，。。。} 合并之后的状态 {reducer1：reducer1(), reducer2: reducer2(), …} 1234567891011&gt; &gt; export function combineReducers(reducers) &#123;&gt; &gt; return (state = &#123;&#125;, action) =&gt; &#123;&gt; &gt; let obj = &#123;&#125;;&gt; &gt; for (let key in reducers) &#123;&gt; &gt; obj[key] = reducers[key](state[key], action)&gt; &gt; &#125;&gt; &gt; return obj;&gt; &gt; &#125;&gt; &gt; &#125;&gt; &gt; &gt; &gt; react 组件中使用redux 定义功能（动作）常量，一般单独放在一个js文件中，action-types.js 12&gt; const INCREMENT = "INCREMENT"&gt; 定义管理员reducer，创建容器store的时候传进reducer 1234567891011&gt; import action-types.js&gt; function reducer(state=initState, action)&#123;&gt; switch(action.type)&#123;&gt; case INCREMENT:&gt; return state + 1&gt; ...&gt; default:&gt; return state&gt; &#125;&gt; &#125;&gt; 定义一个actions，是一个对象，每一个action都需要一个函数返回 123456&gt; let actions = &#123;&gt; add: (count)=&gt;&#123;&gt; return &#123;type: INCREMENT, count&#125;&gt; &#125;,&gt; &#125;&gt; 在组件中 12345678910111213141516171819202122&gt; constructor()&#123;&gt; super();&gt; // 组件状态的初始化&gt; this.state = &#123;number: store.getState().number&#125;&gt; &#125;&gt; &gt; componentDidMount()&#123;&gt; this.unsubscribe = store.subscribe(()=&gt;&#123;&gt; //将redux管理的状态映射到组件自己的状态上&gt; this.setState(&#123;number: store.getState().number&#125;)&#125;)&gt; &#125;&gt; &gt; componentWillUnmount()&#123;&gt; //取消订阅&gt; this.unsubscribe()&gt; &#125;&gt; &gt; render()&#123;&gt; //视图放的一定是组件自己的状态或属性&gt; return &lt;div&gt;&#123;this.state.number&#125;&lt;/div&gt;&gt; &#125;&gt; 派发动作 12&gt; store.dispatch(actions.add(3))&gt; react-reduxreact-redux GitHub地址： `https://github.com/reduxjs/react-redux` react-redux 说明文档： https://react-redux.js.org/ Provider组件，一般是在最外层使用Provider包裹起来，将store 当做属性传给他，被其包裹的组件都可以使用容器store中的状态，但是组件必须使用 connect 方法处理 connect 方法：将组件处理成链接状态的组件 12345&gt; connect (mapStateToProps, mapDispatchToProps)(组件)&gt; //返回一个新的组件&gt; //mapStateToProps：将redux中的状态映射成组件的属性&gt; //mapDispatchToProps:将dispatch派发的动作映射成组件的属性。（也可以直接传一个actions，redux默认会调用 bindActionCreators ，变成dispatch）&gt; 在组件中使用 this.props.xxx 流程图 高阶函数 一个函数返回一个函数let fn = ()=&gt;()=&gt;() 高阶组件 一个组件，返回一个新的组件 手写react-redux12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React from "react"import PropTypes from "prop-types"// Provider 是一个组件，接收一个store属性，将其内容挂载到context上,这样后代才可以有办法拿到class Provider extends React.Component&#123; static childContextTypes = &#123; //设置上下文的类型是对象 store:PropTypes.object &#125;; getChildContext()&#123; //获取并设置后代上下文的内容 return &#123;store:this.props.store&#125; &#125; render()&#123; return this.props.children &#125;&#125;let connect = (mapStateToProps, mapDispatchToProps)=&gt;(C)=&gt;&#123; return class Proxy extends React.Component&#123; static contextTypes = &#123; store:PropTypes.object &#125; constructor(props, context)&#123; super(); //将参数mapStateToProps的解构赋值给代理组件的状态 this.state = mapStateToProps(context.store.getState()) &#125; componentDidMount()&#123; this.context.store.subscribe(()=&gt;&#123; this.setState(mapStateToProps(this.context.store.getState()) &#125;) &#125; render()&#123; return &lt;/C &#123;...this.state&#125; &#123;...mapDispatchToProps(this.context.store.dispatch)&#125; &gt; &#125; &#125;&#125;;export &#123;Provider, connect&#125;]]></content>
      <categories>
        <category>react-redux和redux</category>
      </categories>
      <tags>
        <tag>react-redux和redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware Workstation Pro激活]]></title>
    <url>%2F2018%2F12%2F07%2FVMware-Workstation-Pro%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[下载 到 VMware Workstations 官网下载对应版本的虚拟机。 激活 VMware Workstation Pro 15.0.2 官方版+激活密钥: 123456789101112&gt; ZC10K-8EF57-084QZ-VXYXE-ZF2XF&gt; &gt; UF71K-2TW5J-M88QZ-8WMNT-WKUY4&gt; &gt; AZ7MK-44Y1J-H819Z-WMYNC-N7ATF&gt; &gt; CU702-DRD1M-H89GP-JFW5E-YL8X6&gt; &gt; YY5EA-00XDJ-480RP-35QQV-XY8F6&gt; &gt; VA510-23F57-M85PY-7FN7C-MCRG0&gt;]]></content>
      <categories>
        <category>前端必备软件</category>
      </categories>
      <tags>
        <tag>前端必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebStorm (Jetbrains) 全系列软件永久破解方法]]></title>
    <url>%2F2018%2F12%2F07%2FWebStorm-Jetbrains-%E5%85%A8%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下载 这里以下载 WebStorm 来演示，其他都一样。 到官网 WebStorm 下载软件，还可以点击 Previous versions 下载之前的版本。 注意：由于 WebStorm 最新版不太稳定，用破解补丁破解容易出现闪退现象，建议不下载最新版本的WebStorm 破解补丁激活WebStorm 到百度网盘下载 文件 ，JetbrainsCrack-release-enc.jar，放置到 WebStorm安装目录的\bin目录下（位置可随意，只要配置文件填写相对应的路径）。 在 WebStorm安装目录的\bin目录下找到 WebStorm.exe.vmoptions 和 WebStorm64.exe.vmoptions ，以文本格式打开并同时在两个文件最后追加 -javaagent:G:\你WebStorm的安装路径\bin\JetbrainsCrack-release-enc.jar，注意路径修改成你的WebStorm安装路径，然后保存。 12&gt; -javaagent:G:\webstorm\WebStorm 2018.3.1\bin\JetbrainsCrack-release-enc.jar&gt; 启动WebStorm ,选择激活码激活，输入如下内容激活: 123456789101112131415161718192021222324252627&gt; &gt; ThisCrackLicenseId-&#123;&gt; &quot;licenseId&quot;:&quot;11011&quot;,&gt; &quot;licenseeName&quot;:&quot;WeChat&quot;,&gt; &quot;assigneeName&quot;:&quot;IT--Pig&quot;,&gt; &quot;assigneeEmail&quot;:&quot;1113449881@qq.com&quot;,&gt; &quot;licenseRestriction&quot;:&quot;&quot;,&gt; &quot;checkConcurrentUse&quot;:false,&gt; &quot;products&quot;:[&gt; &#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&gt; &#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;&gt; ],&gt; &quot;hash&quot;:&quot;2911276/0&quot;,&gt; &quot;gracePeriodDays&quot;:7,&gt; &quot;autoProlongated&quot;:false&#125;&gt; &gt;]]></content>
      <categories>
        <category>前端必备软件</category>
      </categories>
      <tags>
        <tag>前端必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[faststone capture 注册码]]></title>
    <url>%2F2018%2F12%2F07%2Ffaststone%20capture%20%E6%B3%A8%E5%86%8C%E7%A0%81%2F</url>
    <content type="text"><![CDATA[下载 点击 FastStone Capture 下载软件 破解 FastStone Capture 8.4 注册码: name：bluman serial/序列号/注册码：VPISCJULXUFGDDXYAUYF FastStone Capture 是一款很好用的截图软件，推荐使用]]></content>
      <categories>
        <category>前端必备软件</category>
      </categories>
      <tags>
        <tag>前端必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10破解]]></title>
    <url>%2F2018%2F12%2F07%2FWindows10%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[下载 到 Windows 10 官网，按照具体步骤下载Windows10系统 破解 到百度网盘下载 破解器 提取码: nrzr 下载完解压到对应的文件夹下，单击运行，稍等一会，破解就成功了。]]></content>
      <categories>
        <category>前端必备软件</category>
      </categories>
      <tags>
        <tag>前端必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adobe系列软件破解]]></title>
    <url>%2F2018%2F12%2F07%2FAdobe%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[下载 到 Adobe 官网 下载你需要的对应的软件。 破解 到百度网盘下载 Adobe 全能软件破解器 提取码: cy4p 下载完解压到对应的目录，双击运行 amtemu.v0.9.2-painter.exe ，选择好要破解的Adobe软件，点击 Install 运行安装，选择对应软件的 amtlib.dll 文件，自动替换为破解后的 amtlib.dll 文件，出现 OK 就是破解成功。]]></content>
      <categories>
        <category>前端必备软件</category>
      </categories>
      <tags>
        <tag>前端必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mark Man 软件破解方法]]></title>
    <url>%2F2018%2F12%2F07%2FMark-Man-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下载 点击 Mark Man 到官网下载软件。 破解 到 百度网盘, 下载 Mark Man 破解版的压缩包，解压到对应的文件夹下。提取码: b68y 安装好MarkMan之后，去安装根目录替换MarkManOne.swf破解成功，无广告，可以保存编辑状态。]]></content>
      <categories>
        <category>前端必备软件</category>
      </categories>
      <tags>
        <tag>前端必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础知识]]></title>
    <url>%2F2018%2F12%2F04%2FGit%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[GIT基础知识 什么是git？ 分布式版本控制系统，它是由Linux（全球比较大的服务器系统）创始人花两周使用C语言编写的，(在GIT命令窗口中一般是执行Linux命令) 什么是版本控制系统？ 能够把之前操作的具体信息记录下来，方便日后的更改。 备份文件 记录历史 回到过去 多端共享 团队协作 常用的版本控制系统 git：分布式版本控制系统 svn：集中式版本控制系统 面试题：分布式和集中式的区别？ [集中式]： 想要做历史记录的查看或者备份，必须连接到中央服务器才可以（需要联网） 处理速度没有git快 [分布式]： 每个开发者本地都是一个单独的仓库，在自己的仓库中就可以完成历史版本记录和查看（不需要联网） git处理的速度更快（git是按照数据存储的） Linux操作系统中常用的命令 ls：查看当前目录下的文件（或文件夹） -l ：查看详细信息 -a：查看隐藏文件 -la：同时具备以上特点 clear：清屏 cd: 目录切换 cd ../ 返回上级目录 cd ./ 返回当前目录 cd / 返回根目录 cd xxx 进入到指定文件夹 cd E 进入到指定的磁盘 mkdir 创建文件夹 touch 创建一个空文件 可以创建无文件名的文件，例如：touch .gitignore 在电脑隐藏文件后缀名的情况下，我们也不至于创建出1.txt.txt这样重复后缀名的文件 vi 向指定文件中插入内容 例如：vi.txt 首先进入命令窗口模式 我们先按i，进入到插入内容模式 编辑需要写的内容 按ESC键，再按英文下的 : 键，再按wq（保存并退出） 按 q！（强制退出，新输入的内容不保存） echo xxx &gt; 1.txt 把xxx内容放到1.txt文件中，如果没有这个文件则创建这个文件（新存放的内容会替换原有文件的内容） echo xxx &gt;&gt; 1.txt 新的内容会追加到原有内容的后面 cat 查看文件中的内容 cp 拷贝文件 rm 删除文件 -r 递归删除（把当前文件夹中所有的后代元素都遍历到删除） -f 强制删除 -rf 上面两种合并到一起，没有办法还原回来，使用要慎重 Git的工作原理和流程 安装完成git后，我们应该先把基础信息配置一下（自己需要配置一次即可） 123456&gt; $ git config -l 查看当前本机的配置清单&gt; $ git config --global user.name xxx &gt; $ git config --global user.email xxx&gt; (xxx写github/coding等平台的账号和邮箱)&gt; &gt; Git的工作流程 Git是分布式版本控制系统，每一台客户端都是一个独立的git仓库（有git工作的全套机制） 一个git仓库分为三个区域; 工作区：平时写代码的地方 暂存区：写好的一些代码暂时存储的地方 历史区：生成一个个版本记录得地方 1.创建GIT仓库 在指定目录中，打开git bash命令行，执行 git init ，相当于以当前目录作为基础，创建了一个本地git仓库 创建完成后，会在项目的根目录中展示 .git 这个隐藏文件：有这个.git文件的才叫做git仓库，没有则不能被称为git仓库（因为暂存区和历史区都是存在 .git 文件夹中的） 2.把工作区的内容提交到暂存区 12345678910&gt; $ git add xxx 把某个文件提交到暂存区&gt; $ git add . 把所有修改的文件（修改和新增的包含，删除的不包含）提交到暂存区&gt; $ git add -u 把所有修改的文件（包含修改和删除的，不包含新增的）&gt; $ git add -A 是点和u的集合体，（所有修改，新增，删除的信息都会提交到暂存区），但是真实效果中两者都差不多，用哪个都可以&gt; &gt; &gt; $ git status 查看当前文件的状态&gt; 红色：在工作区中，还没有提交到暂存区&gt; 绿色：在暂存区中，还没有提交到历史区&gt; 如果在提交的时候，有些内容不想提交，我们可以增加git提交的忽略文件： .gitignore (没有文件名只有后缀名) .gitignore 中的信息： .idea // 使用WS打开项目或者编辑项目，自动会生成的文件 node_modules // 使用npm安装模块的时候，当前安装在项目中的第三方模块都在这个文件夹中（之所以忽略是因为文件太大了） .DS_Store (mac本中的文件)等等 3.把暂存区提交到历史区123456$ git commit$ git commit -m'注释内容'$ git commit -a -m'注释内容' 把提交到暂存区和提交到历史区合并到一起完成。但是只适合已经提交过一次的文件，被修改后可以快速提交。但是对于新增的文件，一次都没有提交过的，是不允许这样操作的。 【root-commit】根提交： 简单理解为：第一次提交到历史区域，如果我们创建一个新的仓库。但是没有做根提交，此时我们仓库中没有任何分支（哪怕是master），也就不存在所谓的分支切换（当前仓库还不完整，只有一个工作流程走完一遍才算完整） 4.工作流中的一些细节知识： 不管是从工作区提交到暂存区，还是从暂存区提交到历史区，每一个区域当前的内容是已知保存下来的不会消失。 123$ git log或$ git reflog 都是查看历史提交记录的（也相当于查看历史版本号），在没有历史版本回滚的时候，我们用哪个都可以。如果有历史版本回滚，git log 只能查看当前回退版本以前的版本 1$ git rm --cached . -r 可以把 . 替换为具体的文件名，这条命令的意思是： 从暂存区把所有内容（或者是你指定的具体文件）都撤回到工作区（不管暂存区中的内容是否已经提交到历史版本上了，也不管是你第几次放到暂存区的，统统撤回到工作区） 这种方式太暴力，我们用的很少，不推荐使用 1$ git checkout . 这条命令的意思是： 把暂存区内容撤回工作去（覆盖现有工作区中的内容无法找回）。 也可以理解为：用上一个暂存区存储的内容覆盖现有工作区的内容，工作区内容变为和上一个暂存区一样的内容，暂存区内容还在。 存在问题：只能限制当前代码还没有提交的情况，当前代码没提交回滚的是上一次提交到暂存区的内容（和工作区内容不一样）；如果当前这次也提交了，暂存区和工作区一样，回滚回来也是一样的，这个方式就解决不了了。 解决问题： 输入命令 $ git reset HEAD . : 在暂存区中，回滚到上一次暂存区中记录的内容（暂存区先回滚一次） 输入命令 $ git checkout . : 把最新暂存区的内容回滚到工作区，替换工作区中的内容 1$ git diff 工作区 VS 暂存区 ：git diff 工作区 VS 历史区 ： git diff master 暂存区 VS 历史区 ： git diff --cached 查看不同区域之间代码的不同，我们一般都是基于可视化的页面来查看不一样的 最重要的代码回滚技巧： 1$ git reset --hard 版本号 git log 可以查看版本号 回滚的时候指定的版本号不一定非常全，有七八位即可 当我们回滚到某一个历史版本之后，暂存区和工作区的内容都将被这个版本内容所代替 1$ history &gt; xxx.txt //（把历史操作步骤输出） 团队协作开发下的git操作 前面讲的都是单独开发，在自己本地建立git仓库的一系列操作流程，在团队写作开发下，流程还是有所区别的 1. 创建中央仓库 一般是由团队技术LEADER或者指派人完成的，仓库中默认是有一些初始化文件的 中央仓库可能是在：gitHub，Coding，自己公司的git仓库服务平台，自己公司的服务器等… 基于gitHub创建远程仓库，创建完成后会生成一个远程地址，例如： https//github.com/username/Repository name.git 作为LEADER，还需要把项目中一些基础的信息提交到远程仓库上： 在自己本地创建一个仓库，把一些基础内容都放在仓库中 把新增加的内容提交到本地仓库历史区中 让本地仓库和远程仓库保持关联 把本地仓库历史区中的信息同步（推送）到远程仓库上 让本地仓库和远程仓库保持关联： 1234567&gt; $ git remote add 名字（一般都叫做origin） 远程仓库地址&gt; &gt; $ git remote rm 名字 // 移除关联&gt; &gt; $ git remote -v // 查看当前仓库和哪些远程仓库保持关联&gt; &gt; 让本地历史区信息和远程仓库信息保持同步： 第一种方法： 12345678&gt; $ git push origin master&gt; // 把本地信息推送到远程仓库上&gt; &gt; $ git pull origin master&gt; // 把远程的拉取到本地仓库&gt; &gt; （origin 是本地和远程仓库关联的那个名字，master 是远程仓库的主分支）&gt; 第二种方法：（推荐使用） 我们创建完成后远程仓库后，可以直接通过 git clone 仓库地址 仓库别名（可以不写） 的方式把远程仓库克隆到本地： 相当于在本地创建了一个仓库 也让本地这个仓库和远程仓库保持了连接（名字：origin） 也把远程仓库现有的内容克隆到了本地 2. 无分支模式下的团队协作 作为开发者每天来的第一件事情或者提交代码之前，都要先pull一下 【如果远程仓库和本地仓库不是同一个文件同一行代码冲突】 git 会自动依赖于 Fast-forward 模式进行合并 自动合并后，我们重新提交即可 git add/commit/push 【同一个文件的同一行代码冲突】 找到冲突的文件，留下自己想要的代码 不管之前是否commit过，都要重新的commit，然后push即可 2.单独分支管理 每天第一件事情，就是创建一个dev分支并切换到这个分支上 正常的开发代码，把每天开发的任务都先提交到自己的分支上 提交到远程仓库上： 把本地自己分支DEV中的内容，合并到本地自己的MASTER 分支下 把自己本地创建的分支删除（可以不删除，但是有的公司不希望远程中出现分支，或者避免开发人员的分支冲突，提交之前都要把自己创建的分支删除掉） 和第一种只使用MASTER分支一样了，把本地最新合并的MASTER分支代码，提交到远程仓库的MADTER下，（冲突合并即可） 操作分支的基础命令： 12345678&gt; $ git branch //查看现有的分支&gt; $ git branch xxx //创建一个新的分支（当切换到某个分支上的时候，会把当前MASTER分支中的新信息同步到这个分支上）&gt; $ git checkout xxx //切换到某个分支上&gt; $ git checkout -b xxx //创建一个新的分支并且切换到这个分支上&gt; $ git branch -D xxx //删除某个分支（一定要切换到其他分支上才可以删除当前分支）&gt; $ git merge xxx //合并分支内容&gt; $ git log --graph / --oneline //再有分支的情况下，可以更清楚地查看分支的提交和合并内容（了解就好）&gt; GitHub界面操作给别的仓库提交代码修改或建议 首先fork别人的仓库 把别人的仓库克隆一份一模一样的，放到自己的账号下，变为自己的仓库（我们平时可以修改自己仓库的源码） fork的仓库和别人的原始的仓库会默认建立一些关系，我们可以把自己仓库中和别人不一样的地方，提交给别人，用（pull-request） 把自己fork的仓库，克隆到本地 以后自己有一些新的代码心得，可以自己尝试去修改，然后同步到自己fork的仓库中 在github中点击 new pull request GitHub还可以发布非后台项目 GitHub只提供了web站点的发布，后台项目没有提供必要的环境 把整个仓库作为一个项目发布（这种模式不常用） master是项目代码，gh-pages分支下存储的是项目预览页面的代码 其他人克隆研究的是master分支下的代码 看介绍页面，看的是gh-pages分支下的代码 创建一个仓库 把仓库克隆到本地 把源码传到master分支上 在本地仓库中创建gh-pages分支 把介绍页面放在gh-pages分支下 把介绍页面的内容上传到github的gh-pages分之下 访问页面：http://用户名.github.io/仓库名/页面名.html （如果页面是index可以忽略不写） 把自己写的纯静态页面项目通过github地址可以看到页面效果 第一步，在github上新建一个仓库，把远程仓库通过 git clone xxx克隆到本地 第二步，把自己写好的作品放在本地仓库中 第三步，通过git add -A , git commit -m, git push origin master 三步操作，把自己的项目同步到远程仓库github中 以后修改后，重新执行这三步推送即可 在投简历的时候，把网址 https://用户名.github.io/仓库名 写到简历上就可以访问到页面效果。如果觉得地址太长不好记，也可以通过草料二维码 ,来制作自己喜欢的二维码]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Node+Git搭建博客]]></title>
    <url>%2F2018%2F12%2F03%2FHexo-Node-Git%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[从零开始搭建博客第一部分，Github注册及Github Pages建立 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 一：注册Github1：打开Github首页，点击Sign up 进行注册。 二：Github Pages 静态网页建立1：在新页面点击 NEW 按钮，创建属于自己的新仓库。 2: 点击 Code3: 点击 Create new file4: 输入 index.html，在 Edit new file 书写内容。5：点击 Commit new file 进行创建。6：用浏览器打开 用户名.github.ioGithub Pages 静态网页建立完成。 三：Hexo博客本地环境安装1: 安装 Node2: 安装 Git4: 初始化 Hexo 电脑中任选盘符新建一个文件夹作为博客网站的根目录，文件名好不要是中文。 空白处右键点击 Git Bash Here 安装 Hexo1$ npm install -g hexo-cli 等待运行完成后依次输入以下命令 123$ hexo init &lt;新建文件夹的名称&gt;$ cd &lt;新建文件夹的名称&gt;$ npm install 注意:后续的命令均需要在站点目录下（即文件夹内）使用Git Bash运行。 此时Hexo框架的本地搭建已经完成了。我们来运行一下看看： 命令行依次输入以下命令: 123$ hexo clean #清除浏览器缓存$ hexo g$ hexo s 浏览器中打开(http://locakhost:4000)或者(127.0.0.1:4000),说明Hexo博客已经成功在本地运行。 四：本地博客发布到Github Pages1：需要在Github上创建好Github Pages仓库2：安装将 Hexo 部署到 Git 的插件 在站点目录中运行命令行输入 npm install hexo-deployer-git --save 后续还要安装各种插件，实现博客的各种功能。等待插件安装完成 3：将本地目录与Github关联起来 命令行输入 1$ ssh-keygen -t rsa -C "邮箱地址" 1： 这里要输入之前注册Github时的邮箱，例如我之前注册用的是 123@qq.com，那命令行就输入ssh-keygen -t rsa -C “123@qq.com“输入后一直回车。 2：打开 C:\Users\ 用户名，文件夹内寻找 .ssh 文件夹 3：文件夹内会有两个文件，一个id_rsa.pub一个id_rsa，用文本方式打开id_rsa.pub，推荐使用Vscode 打开，复制里面的的内容。 4：打开Github 点击右上角的头像 Settings 选择SSH and GPG keys 5：点击 New SSH key 将之前复制的内容粘帖到Key的框中。 上面的title 可以随意 点击 Add SSH key 完成添加。 6: 此时回到命令行。 试一下是否跟Github连接成功。命令行输入ssh -T git@github.com，弹出的内容输入yes，看到出现Hi ! You’ve successfully authenticated, but GitHub doesnot provide shell access. 说明链接成功。此处这个应该是你Github的用户名。 4: 修改Hexo站点的 _config.yml文件 进入博客文件夹， 找到 _config.yml 博客的配置文件。以后修改博客的样式或内容会多次用到它。 123456789101112# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: #网站标题subtitle: #网站副标题description: #网站描述 主要用于SEOkeywords: #网站关键词 主要用于SEOauthor: #网站作者language: zh-CN #网站语言timezone: #网站时区：Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 123456# URL 网址## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: #修改为https://&lt;用户名&gt;.github.ioroot: / #如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。permalink: :year/:month/:day/:title/ #文章的永久链接格式permalink_defaults: #永久链接中各部分的默认值 在文件底部 deploy 添加如下代码： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署部分的设置type: gitrepo: git@github.com:&lt;Github用户名&gt;/&lt;github用户名&gt;.github.io.gitbranch: master 5: 保存配置，将生成的本地页面上传至Github 命令行输入hexo g，此时Hexo会根据配置文件渲染出一套静态页面。 完成后输入hexo d，此时会将之前渲染出的一系列文件上传至Github。 注意：也可以直接输入hexo g -d直接完成渲染和上传。 上传完成后，打开https://&lt;用户名&gt;.github.io查看上传的网页。如果页面变成了之前本地调试时的样子，说明上传以及完成了。没变的话查看一下上传时命令行窗口的信息有没有错误信息，没有的话清除一下浏览器缓存试试。 五：Hexo博客主题安装及Next主题个性化修改基于Next主题的修改和配置 注意：博客配置文件是指博客根目录下的_config.yml文件，主题配置文件是指/themes/主题名/路径下的_config.yml文件，例如我使用的主题为next主题，主题配置文件为_/themes/next/config.yml。 1：主题选择 到 Nexo官网主题页选择喜欢的主题。每个主题配置方法略有不同，建议使用流行主题，推荐Next主题，因为我的博客就是用Next主题搭建的。 2：主题修改主题安装 Next主题文档页面 Nest主题Github页面 博客根目录打开命令行输入 1git clone https://github.com/theme-next/hexo-theme-next themes/next 1：安装完成后，打开 博客配置文件 修改theme 主题： 1234# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #当前主题名称。值为false时禁用主题 2：修改 主题配置文件 是根目录/themes/next目录下的_config.yml文件。 修改菜单及创建分类页 1:定位到 Hexo 站点目录下,在命令行输入如下命令： 1$ hexo new page tags 新建出标签页 同样的道理，开启分类页的时候要输入hexo new page categories来新建出分类页。 2:设置页面类型：编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 12345---title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;--- 3:修改 主题配置 文件下的menu项： 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 修改主题风格 Next自带四种主题风格，可以在主题配置文件搜索Scheme项，将需要的风格前的#去掉，注意只能开启一个风格。 12345678# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 设置作者头像 编辑主题配置文件，搜索修改字段 avatar， 值设置成头像的链接地址。可以设置成在线的图片地址。也可以把图片放在本地。 本地设置：放置在source/images目录下，设置为url: /images/avatar.jpg 123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/cat.jpg # If true, the avatar would be dispalyed in circle. rounded: false # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true 设置作者昵称与站点描述12345678# Site 网站title: #网站标题subtitle: #网站副标题description: #网站描述 主要用于SEOkeywords: #网站关键词 主要用于SEOauthor: #网站作者language: zh-CN #网站语言timezone: #网站时区：Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 设置代码高亮主题 NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties： 编辑主题配置文件，更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如： 1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 侧边栏社交链接 侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 1234567891011121314151617# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@qq.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。 1234social_icons: enable: true icons_only: false transition: false 开启打赏功能 越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 123456789# Reward# If true, reward would be displayed in every article by default.# And you can show or hide one article specially through add page variable `reward: true/false`.reward: enable: true comment: 如果觉得文本对您有帮助，欢迎打赏 wechatpay: /images/wechat.png alipay: /images/zhifubao.jpg bitcoin: /images/qq.png 注意：将保存的图片放到 /source/images/图片名称 修改打赏字体不闪动 鼠标一指就疯狂抖动。 修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数#QR &gt; div:hover p函数即可。css文件注释用/ 和 / 包裹代码即可。 12345#QR &gt; div:hover p &#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; 这个post-reward.styl文件是跟按钮及图片相关的，如果需要修改关于打赏的其他属性，例如按钮大小，样式，图片大小等，都可以修改post-reward.styl文件实现。 开启友情链接 or 侧边栏推荐阅读 主题配置文件 中搜索links_title字段，修改links_icon、links_title、links_layout、links四个字段的内容实现自定义风格。 link_icon是title前面的图标，用法跟之前的社交链接的图标用法是一样的， 用Font Awesome图标。links_title为标题，如果是作为友情链接使用，可以设置为links_title: 友情链接在links字段设置友情链接名字及链接 这个模块的自由度比较高，可以用来放置友情链接，也可以放置推荐阅读。 1234567# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links: #Title: http://example.com hexo生成博文插入图片显示不出来 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 完成安装后用hexo新建文章 hexo new &quot;文章标题&quot; 的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。 只要使用![logo](本地图片测试/logo.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题。 文章左侧的目录如何弄出来？ 1、首先在你的markdown文件里面要有标题，所谓标题就是例如这种一级标题(#)，二级标题(##)，三级标题(###)的。 2、在主题的_config文件里面，将toc的enable设置为true就ok了，默认的目录是有序号的，如果你不想要序号，你需要把number置为false 。 设置 RSS NexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置 文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。 安装方法：根目录下命令行输入npm install hexo-generator-feed --save 具体的链接地址：适用于已经烧制过Feed的情形。建议直接使用插件，比较省事。 设置网站图标 在EasyIcon中分别找一张（16 16与32 32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon16.ico与favicon32.ico。 把图标放在/themes/next/source/images或者放在根目录的/source/images文件夹里。 在 主题配置文件 内搜索favicon字段，把 small、medium字段的地址修改为/images/favicon16.ico 与 /images/favicon32.ico。 实现全站及文章字数统计及阅读时长 根目录命令运行： 1npm install hexo-symbols-count-time --save 博客配置文件底部添加如下内容，保存。 1234567# 1，实现全站及文章数字统计及阅读时长# 运行 npm install hexo-symbols-count-time --savesymbols_count_time: symbols: true time: true total_symbols: true total_time: true 添加顶部加载条 根目录打开命令行，输入如下命令： 1git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace 然后主题配置文件搜索pace字段，修改pace: false为pace: true即可开启加载条功能，修改下方的pace-theme字段还可以修改加载条的样式。 1234567891011121314151617181920# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For examplepace_theme: pace-theme-center-simple# pace_theme: pace-theme-minimal 自定义鼠标样式 打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码: 1234567// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 在EasyIcon中找一张16 * 16的ico图，放在/source/images/中，修改上述代码中的链接为/images/xxx.ico，如果不放在本地的话，可以把图片放在图床，直接替换链接即可。 第一行的链接是默认状态下的鼠标样式，第二行的是鼠标按下时的样式。 1234567// 鼠标样式 * &#123; cursor: url(&quot;/images/cat.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;&quot;/images/cat2.ico&quot;&quot;),auto!important &#125; 实现点击出现桃心 以及 爆炸效果 在/themes/next/source/js/src下新建文件love.js并填入如下代码： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 或建一个叫fireworks.js的文件并写入如下代码： 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在上面写下如下代码： 123456789&#123;% if theme.fireworks &amp;&amp; not theme.love %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;&#123;% if theme.love &amp;&amp; not theme.fireworks %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 在 主题配置文件 最下方加入如下代码： 123# Fireworks and lovefireworks: truelove: false 注意：fireworks是爆炸效果，love是心形效果。两个不能同时开。 修改网页底部的小图标 在 主题配置文件 搜索footer字段，修改下方的icon字段下的name字段。name字段后的名字是 Font Awesome 图标的名字（不必带 fa- 前缀）。 1234567891011121314footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: user # If you want to animate the icon, set it to true. animated: true #animated自动为闪动开关，设置为true后图标会闪动。 # Change the color of icon, using Hex Code. color: &quot;#808080&quot; 去掉页面底部的强力驱动信息及设置备案信息 主题配置文件搜索copyright字段，修改powered下的enable字段的true为false即可去掉强力驱动部分的内容 1234567891011121314151617181920# If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: true # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: #如果博客有备案的话，下方beian字段设置为true，icp后填写备案号。 enable: false icp: 添加动态背景注意：尽量不要添加，耗费资源较大，加载速度非常慢 1.根目录打开命令行，输入： 1$ git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest 2.主题配置文件搜索canvas-nest字段，enable项设置为true。 123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: false onmobile: true # display on mobile or not color: &apos;0,0,255&apos; # RGB values, use &apos;,&apos; to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 3.其他配置项说明： color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 onmobile：是否在手机端显示。 增加波浪背景动画 根目录打开命令行，输入: 1git clone https://github.com/theme-next/theme-next-three themes/next/source/lib/three 主题配置文件搜索three_waves字段，设置为true 1234567891011# Internal version: 1.0.0 # See: https://github.com/theme-next/theme-next-three # Example: # three: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/three.min.js # three_waves: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/three-waves.min.js # canvas_lines: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/canvas_lines.min.js # canvas_sphere: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/canvas_sphere.min.js three: three_waves: canvas_lines: canvas_sphere: three_waves、canvas_lines、canvas_sphere三个的效果各不相同，可以自己尝试一下选一个喜欢的。 添加静态背景 打开博客根目录/themes/next/source/css/_custom/custom.styl文件，编辑如下： 123456// Custom styles.body &#123; background-image: url(/images/background.png); //动图也可以添加 background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: contain; // 等比例铺满屏幕 博客主页自定义样式修改 打开博客根目录/themes/next/source/css/_custom/custom.styl文件: 用 css 语言修改自己想要的主页样式就可以 在右上角实现fork me on github按钮 最新的Next主题已经内置了增加右上角的Fork me on github按钮功能，只需要在主题配置文件搜索github_banner字段，去掉前面的#，把||前面的github链接替换成自己的即可。 12345# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.github_banner: https://github.com/wudiufo || Follow me on GitHub ||后的参数为按钮的title，为鼠标指在按钮上时显示的文本。 增加回到顶部按钮及显示当前浏览进度 主题配置文件搜索b2t字段，将b2t字段的false修改为true即可，（注意此功能只能用于Pisces和Gemini主题）。 123456789# Back to top in sidebar (only for Pisces | Gemini). b2t: true # Scroll percent label in b2t button. # scrollpercent字段设置为true即可实现当前浏览进度的显示。 scrollpercent: true # Enable sidebar on narrow view (only for Muse | Mist). onmobile: true 修改顶部菜单与下方信息栏的间隙大小 主题配置文件搜索offset字段，将offset的像素数大小设置为需要的值，默认为12。 12# Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 网站标题栏背景颜色 打开 themes/next/source/css/_custom/custom.styl ,在里面写下如下代码： 1234// 网站标题栏背景颜色.site-meta &#123; background: #FF0033; //修改为自己喜欢的颜色&#125; 为博客加上萌萌的动图 首先安装插件，根目录命令行输入： 1$ npm install --save hexo-helper-live2d 主题配置文件最下方添加如下代码: 123456789101112131415161718192021# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: true scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 更多设置可以查看官方文档 添加DaoVoice 实现在线联系 本功能可以实现在线留言，作者会收到邮件，如果绑定了微信，作者还会收到微信通知。 首先到DaoVoice注册一个Daovioce账号。 注册完成后会进到DaoCloud，重新访问连接即可。进到Daovoice面板，点击左侧边栏的应用设置– 安装到网站。在下方的代码中会看到app_id: “xxxx”字样。 打开 themes/next/layout/_partials/head/head.swig 文件中最下方加入如下代码： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件 _config.yml，添加如下代码： 123# DaoVoice daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 回到Daovoice控制面板，点击聊天设置可以对聊天图标的颜色及位置进行设置。 最后到右上角选择管理员，微信绑定，可以绑定你的微信号。这样收到消息后可以通过小程序进行回复。 主页文章添加阴影效果 打开\themes\next\source\css_custom\custom.styl,加入如下代码： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 可以自行修改代码来修改阴影效果 增加本地搜索功能 首先安装插件，根目录命令行输入: 1$ npm install hexo-generator-searchdb --save 编辑博客配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 主题配置文件搜索local_search字段，设置enable为true 123# Local searchlocal_search: enable: true 添加图片懒加载 博客根目录打开命令输入 1$ git clone https://github.com/theme-next/theme-next-jquery-lazyload themes/next/source/lib/jquery_lazyload 然后在配置文件中搜索 lazyload,将其修改为true123# Added switch option for separated repo in 6.0.0.# Dependencies: https://github.com/theme-next/theme-next-jquery-lazyloadlazyload: true 添加评论添加方法 在来必力的官网上注册账号。 在此处获取data-uid。 打开NexT主题的配置文件—config中，搜索livere_uid，将livere_uid前面的#号去掉，将id填写到livere_uid：后面。 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid 代码块复制功能前言为了提高博客代码块的用户体验，仅仅代码高亮还不行，最好还能一键复制代码。故此文将讲述Hexo Next主题博客的代码块复制功能配置。 下载需要下载 clipboard.js 主页 Github 提供下载:（推荐用这个） clipboard.min.js 将下载的文件存到如下目录：（相对目录为工程目录，没有目录则创建） .\themes\next\source\lib\zclip\clipboard.min.js 导入 新建文件 custom.js，目录如下：（相对目录为工程目录） \themes\next\source\js\src\custom.js 修改 custom.js为如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css("left", -$copyBtn.width() - 3); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 配置 新建文件 custom.swig ，目录：.\themes\next\layout_custom\custom.swig（相对目录为工程目录） 12&lt;script type=&quot;text/javascript&quot; src=&quot;/lib/zclip/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/custom.js&quot;&gt;&lt;/script&gt; 修改文件 _layout.swig ，目录：\themes\next\layout\_layout.swig（相对目录为工程目录） 添加如下代码： 12345678&lt;!doctype html&gt; &#123;% include &apos;_third-party/math/mathjax.swig&apos; %&#125; &#123;% include &apos;_custom/custom.swig&apos; %&#125;&lt;/body&gt;&lt;/html&gt; 向文件中 &lt;/body&gt; 前一行插入文件引用，如第 15 行效果。 1&#123;% include &apos;_custom/custom.swig&apos; %&#125; 在主题配置文件_config.yml中找到以下代码： 将enable修改为true，show_result修改为true 123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true 六：Hexo撰写文章一、创建文章 在站点文件夹中打开git bash，输入如下命令创建文章，其中title为文章的标题： 1hexo new "title" 此时就会在source/_post文件夹中创建了一个文件，命名为：title.md，而这个文件就是将要发布到网站上的原始文件，记录文章内容，以下我们将要在这个文件中写下我们的第一篇博客 二、编写文章（基于Markdown） 推荐大家一款简洁易用的markdown编辑器 Typora,点击下载。 Markdown语法及在线编辑 1.模板设置 当我们使用命令 hexo new “title” 去创建我们的文章时，Hexo会根据/scaffolds/post.md文件对新建文件进行初始化，换言之，/scaffolds/post.md文件就是创建新文章的模板，所以我们可以修改它来适应自己的写作习惯，一个简单的示例如下： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: categories: --- 2.头部设置 在博客文章的开头会有对文章的说明文字，叫做文章头部，文章的头部除了可以设置文章标题、书写日期等基础信息外，还可以对文章添加标签、分类等，一个简单的示例如下: 1234567891011121314---title: Title #标题date: YYYY-MM-DD HH:MM:SS #文件建立日期tags: #标签（不适用于分页）- 标签1- 标签2categories: #分类（不适用于分页）- 分类1- 分类2layout: #布局updated: YYYY-MM-DD HH:MM:SS #文件更新日期comments：true #开启文章的评论功能permalink：覆盖文章网址--- 注意，属性和属性值之间必须有一个空格，否则会解析错误 3.首页显示 1.在Hexo框架博客的首页会显示文章的内容（默认显示文章的全部内容），如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简，只需在文章中使用 &lt;!--more--&gt;标志，表示只会显示标志前面的内容 2.推荐使用： 在主题配置文件中找到auto_excerpt，将enable变为true，代码如下： 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 #长度可自由调节 三，顶部统计每篇文章阅读次数在主题配置文件中查找busuanzi_count,将其按照如下方式修改： 12345678910# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 七，生成sitemap站点地图百度+谷歌都无法搜索到我的博客 不能忍 1.先确认博客是否被收录 在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有。 1site:写你要搜索的域名 # site:wudiufo.github.io 2.创建站点地图文件 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件: 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客根目录的_config.yml中添加如下代码: 12345baidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 执行以下命令，编译你的博客 1$ hexo g 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了 执行 hexo s 看站点地图是否生成 3.让百度,360和谷歌收录我们的博客验证网站在百度和360，谷歌上分别搜索： 1site:写你要搜索的域名 # site:wudiufo.github.io 其中的域名换成你的博客域名，如果此前没有进行过操作，应该是搜不到的，并且搜索出来的结果含有搜索引擎提交入口 分别进入搜索引擎提交入口，添加域名，选择验证网站，有3种验证方式，本文推荐采用HTML标签验证 这里演示百度站长平台 打开Hexo主题配置文件，添加以下两行: 12google_site_verification: #索引擎提供给你的HTML标签的content后的字符串baidu-site-verification: #索引擎提供给你的HTML标签content后的字符串 还有其他搜索引擎，自行添加 然后运行： 12hexo clean &amp;&amp; hexo generatehexo deploy 然后点击验证，就可以通过验证了 4，百度自动推送 将主题配置文件中的baidu_push设置为true，然后将/next/layout/_scripts文件夹下面的baidu-push.swig文件中的 ` ` 替换为百度提供的自动推送代码,如下： 1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 5.谷歌收录我们的博客谷歌操作比较简单，就是向Google站长工具提交sitemap登录Google账号，添加了站点验证通过后，选择站点，之后在抓取——站点地图——添加/测试站点地图]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo+Node+Git搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
